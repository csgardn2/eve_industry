/// @file raw_order.h
/// @brief Declaration of @ref raw_order_t class
/// 
/// * Contact conor.gardner@arm.com if you have questions about this code.
/// * Date Created = Tuesday October 31 2017
/// * Documentation is generated by doxygen, see documentation/html_out/index.html

#ifndef HEADER_GUARD_ORDER
#define HEADER_GUARD_ORDER

#include <fstream>
#include <string_view>

#include "error.h"
#include "json.h"

/// @brief Indicates if a market bid is a buy or sell order.
enum class order_type_t
{
    /// @brief The person who placed the bid wants to buy this item.
    BUY,
    /// @brief The person who placed this bid wants to sell this item.
    SELL,
    /// @brief This must be last.
    NUM_ENUMS
};

/// @brief A market bid fetched from the EvE Swagger API with minimal
/// post-processing.
class raw_order_t
{
        
    public:
        
        /// @brief Default constructor
        inline raw_order_t() = default;
        
        // Add member initialization constructors here
        
        // Try to use initializer lists when possible.
        inline raw_order_t(float price, uint64_t item_id, uint64_t station_id, order_type_t order_type)
          : price_(price),
            item_id_(item_id),
            station_id_(station_id),
            order_type_(order_type)
        {
            // All work done in initializer list
        }
        
        // Add operators here if desired.
        // inline type operator[](unsigned ix) const;
        // inline type& operator[](unsigned ix);
        
        /// @brief Returns true if all members are equal
        inline bool operator==(const raw_order_t& source) const
        {
            return
                this->price_ == source.price_
             && this->item_id_ == source.item_id_
             && this->station_id_ == source.station_id_
             && this->order_type_ == source.order_type_;
        }
        
        /// @brief 1:1 inverse of @ref operator==(const raw_order_t& source) const "operator==".
        inline bool operator!=(const raw_order_t& source) const
        {
            return !(*this == source);
        }
        
        // Add member read and write functions
        // inline type member() const;
        // inline void member(const type& t);
        
        inline float price() const
        {
            return this->price_;
        }
        
        inline void price(float new_price)
        {
            this->price_ = new_price;
        }
        
        inline uint64_t item_id() const
        {
            return this->item_id_;
        }
        
        inline void item_id(uint64_t new_item_id)
        {
            this->item_id_ = new_item_id;
        }
        
        inline uint64_t station_id() const
        {
            return this->station_id_;
        }
        
        inline void station_id(uint64_t new_station_id)
        {
            this->station_id_ = new_station_id;
        }
        
        inline order_type_t order_type() const
        {
            return this->order_type_;
        }
        
        inline void order_type(order_type_t new_order_type)
        {
            this->order_type_ = new_order_type;
        }
        
        /// @brief Open a file conforming to data/json/schema.json and use it to initialize
        /// this object, clearing previous content.
        ///
        /// @exception error_message_t
        /// @exception Json::Exception
        void read_from_json_file(std::istream& file);
        
        /// @brief Decode serialized content conforming to data/json/schema.json and use it
        /// to initialize this object, clearing previous content.
        ///
        /// @exception error_message_t
        /// @exception Json::Exception
        void read_from_json_buffer(std::string_view buffer);
        
        /// @brief Extract required data fields from a pre-parsed JSON tree
        /// and use them to initialize this object, clearing previous content.
        ///
        /// @exception error_message_t
        void read_from_json_json(const Json::Value& json_root);
        
        /// @brief Serialize the content of this file into a file that
        /// conforms to the schema data/json/schema.json.
        void write_to_json_file
        (
            /// [out] Stream to append serialized object content to.
            std::ostream& file,
            /// [in] The number of space ' ' characters to prepend to each line
            /// in the serialized output.
            unsigned indent_start = 0,
            /// [in] The number of additional spaces ' ' on top of indent_start
            /// to prepend to each line in the serialized output for each
            /// additional level of nesting.
            ///
            /// Indentation typically increases after each opening bracket '['
            /// or brace '{' and decreases after each closing bracket ']' or
            /// brace '}'.
            unsigned spaces_per_tab = 4
        ) const;
        
        /// @brief Serialize the content of this file into a string that
        /// conforms to the schema data/json/schema.json.
        ///
        /// @exception error_message_t
        void write_to_json_buffer
        (
            /// [out] This string is overwritten with serialzed JSON content.
            std::string& buffer,
            /// [in] The number of space ' ' characters to prepend to each line
            /// in the serialized output.
            unsigned indent_start = 0,
            /// [in] The number of additional spaces ' ' on top of indent_start
            /// to prepend to each line in the serialized output for each
            /// additional level of nesting.
            ///
            /// Indentation typically increases after each opening bracket '['
            /// or brace '{' and decreases after each closing bracket ']' or
            /// brace '}'.
            unsigned spaces_per_tab = 4
        ) const;
        
        /// @brief Convinence method for pretty initialize-on-construction
        /// syntax.
        inline std::string write_to_json_buffer
        (
            /// [in] The number of space ' ' characters to prepend to each line
            /// in the serialized output.
            unsigned indent_start = 0,
            /// [in] The number of additional spaces ' ' on top of indent_start
            /// to prepend to each line in the serialized output for each
            /// additional level of nesting.
            ///
            /// Indentation typically increases after each opening bracket '['
            /// or brace '{' and decreases after each closing bracket ']' or
            /// brace '}'.
            unsigned spaces_per_tab = 4
        ) const {
            std::string buffer;
            this->write_to_json_buffer(buffer, indent_start, spaces_per_tab);
            return buffer;
        }
        
    protected:
        
        // Try to make all your members protected, even if they don't
        // really need to be.
        
        /// @brief The asking price for this bid.
        float price_;
        
        /// @brief The integral uniquifier of the inventory item associated
        /// with these bid.
        uint64_t item_id_;
        
        /// @brief The integral uniquifier of the NPC station of this bid.
        uint64_t station_id_;
        
        /// @brief Indicates if this order is a buy or sell order.
        order_type_t order_type_;
        
};

/// @brief Convenience alias to allow printing directly via cout or similar.
inline std::ostream& operator<<(std::ostream& stream, const raw_order_t& source)
{
    source.write_to_json_file(stream);
    return stream;
}

/// @brief Extraction operator for decoding.
std::istream& operator>>(std::istream& stream, raw_order_t& destination);

#endif // Header Guard

