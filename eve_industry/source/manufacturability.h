/// @file manufacturability.h
/// @brief Declaration of @ref manufacturability_t class
/// 
/// * Contact conor.gardner@arm.com if you have questions about this code.
/// * Date Created = Thursday November 16 2017
/// * Documentation is generated by doxygen, see html/index.html

#ifndef HEADER_GUARD_manufacturability
#define HEADER_GUARD_manufacturability

#include <fstream>
#include <string>
#include <string_view>

#include "error.h"
#include "json.h"

/// @brief Indicates if a blueprint can be manufactured (and invented if it's
/// a T2 blueprint).
class manufacturability_t
{
        
    public:
        
        /// @brief Indicates the type of problem (if any) that is preventing
        /// a blueprint from being manufactured
        enum class status_t {
            /// @brief No problems, ready to manufacture.
            OK,
            /// @brief A price wasn't found for an input item or the output item.
            MISSING_MARKET_DATA,
            /// @brief Cannot find the T1 blueprint used to create a copy for
            /// invention
            INVENT_CANNOT_FIND_REQUISITE_T1,
            /// @brief The T1 blueprint required to invent a T2 blueprint
            /// cannot be copied.
            INVENT_CANNOT_COPY_REQUISITE_T1,
            // NUM_ENUMS element must be last
            NUM_ENUMS
        };
        
        /// @brief Default constructor
        inline manufacturability_t() = default;
        
        // Add member initialization constructors here
        // Try to use initializer lists when possible.
        
        // Add operators here if desired.
        
        // Add member read and write functions
        
        inline status_t status() const
        {
            return this->status_;
        }
        
        inline void status(status_t new_status)
        {
            this->status_ = new_status;
        }
        
        inline const std::string& message() const
        {
            return this->message_;
        }
        
        inline void message(std::string_view new_message)
        {
            this->message_ = new_message;
        }
        
        // Add special-purpose functions here
        
        inline bool is_ok() const
        {
            return this->status_ == status_t::OK;
        }
        
        // Add encoders/decoders here
        
        /// @brief Open a file conforming to data/json/schema.json and use it to initialize
        /// this object, clearing previous content.
        ///
        /// @exception error_message_t
        /// @exception Json::Exception
        void read_from_json_file(std::istream& file);
        
        /// @brief Decode serialized content conforming to data/json/schema.json and use it
        /// to initialize this object, clearing previous content.
        ///
        /// @exception error_message_t
        /// @exception Json::Exception
        void read_from_json_buffer(std::string_view buffer);
        
        /// @brief Extract required data fields from a pre-parsed JSON tree
        /// and use them to initialize this object, clearing previous content.
        ///
        /// @exception error_message_t
        void read_from_json_structure(const Json::Value& json_root);
        
        /// @brief Serialize the content of this file into a file that
        /// conforms to the schema data/json/schema.json.
        void write_to_json_file
        (
            /// [out] Stream to append serialized object content to.
            std::ostream& file,
            /// [in] The number of space ' ' characters to prepend to each line
            /// in the serialized output.
            unsigned indent_start = 0,
            /// [in] The number of additional spaces ' ' on top of indent_start
            /// to prepend to each line in the serialized output for each
            /// additional level of nesting.
            ///
            /// Indentation typically increases after each opening bracket '['
            /// or brace '{' and decreases after each closing bracket ']' or
            /// brace '}'.
            unsigned spaces_per_tab = 4
        ) const;
        
        /// @brief Serialize the content of this file into a string that
        /// conforms to the schema data/json/schema.json.
        ///
        /// @exception error_message_t
        void write_to_json_buffer
        (
            /// [out] This string is overwritten with serialzed JSON content.
            std::string& buffer,
            /// [in] The number of space ' ' characters to prepend to each line
            /// in the serialized output.
            unsigned indent_start = 0,
            /// [in] The number of additional spaces ' ' on top of indent_start
            /// to prepend to each line in the serialized output for each
            /// additional level of nesting.
            ///
            /// Indentation typically increases after each opening bracket '['
            /// or brace '{' and decreases after each closing bracket ']' or
            /// brace '}'.
            unsigned spaces_per_tab = 4
        ) const;
        
    protected:
        
        // Try to make your members protected, even if they don't have to be.
        
        /// @brief See @ref status_t
        status_t status_;
        
        /// @brief Optional human readable message for diagnosing a specific
        /// issue that caused @ref status_ to be anything other than OK.
        ///
        /// Since this field is optional, an error will not be thrown if this
        /// field cannot be found during decoding.
        ///
        /// If this field is initialized, it will be written during encoding.
        std::string message_;
        
};

/// @brief Convenience alias to allow printing directly via cout or similar.
inline std::ostream& operator<<(std::ostream& stream, const manufacturability_t& source)
{
    source.write_to_json_file(stream);
    return stream;
}

/// @brief Extraction operator for decoding.
std::istream& operator>>(std::istream& stream, manufacturability_t& destination);

#endif // Header Guard

