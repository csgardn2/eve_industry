/// @file item_quantities.cpp
/// @brief Implementation of @ref item_quantities_t class
/// 
/// * Contact conor.gardner@arm.com if you have questions about this code.
/// * Date Created = Friday November 24 2017
/// * Documentation is generated by doxygen, see html/index.html

#include <fstream>
#include <string>
#include <string_view>

#include "item_quantities.h"
#include "error.h"
#include "json.h"
#include "station_market.h"

float item_quantities_t::total_sell_value(const station_market_t& station_market, unsigned material_efficiency) const
{
    
    float accumulator = 0.0f;
    unsigned scale_material_efficiency = 100 - material_efficiency;
    std::unordered_map<uint64_t, item_market_t>::const_iterator not_found = station_market.end();
    
    for (const item_quantity_t& cur_item_quantity : this->materials_list_)
    {
        
        std::unordered_map<uint64_t, item_market_t>::const_iterator cur_item_market = station_market.items().find(cur_item_quantity.item_id());
        if (cur_item_market == not_found)
        {
            std::string message("Error.  Could not find sell order for item with id ");
            message += std::to_string(cur_item_quantity.item_id());
            message += '.';
            throw error_message_t(error_code_t::NO_ORDERS, message);
        }
        
        // Round up to the nearest integer
        unsigned rounded_modified_materials = (cur_item_quantity.quantity() * scale_material_efficiency + 99) / 100;
        
        // This integer rounding error (during divide) is intentional
        // to match EvE's rounding rules.
        accumulator += float(rounded_modified_materials) * cur_item_market->second.min_sell_order();
    }
    
    return accumulator;
    
}

void item_quantities_t::read_from_json_file(std::istream& file)
{
    
    // Get the number of characters in the input file.
    if (!file.good())
        throw error_message_t(error_code_t::FILE_SIZE_FAILED, "Error.  Failed to determine file size when encoding item_quantities_t object.");
    file.seekg(0, std::ios_base::end);
    unsigned file_size = file.tellg();
    file.seekg(0, std::ios_base::beg);
    
    // Read the entire file into RAM at once
    std::string buffer(file_size, '\0');
    file.read(buffer.data(), file_size);
    if (!file.good())
        throw error_message_t(error_code_t::FILE_READ_FAILED, "Error.  Failed to read file when decoding item_quantities_t object.");
    this->read_from_json_buffer(std::string_view(buffer));
    
}

void item_quantities_t::read_from_json_buffer(std::string_view buffer)
{
    
    Json::CharReaderBuilder builder;
    Json::CharReader* reader = builder.newCharReader();
    
    Json::Value json_root;
    std::string error_message;
    bool success = reader->parse(buffer.begin(), buffer.end(), &json_root, &error_message);
    delete reader;
    if (!success)
        Json::throwRuntimeError(error_message);
    
    // Now that the JSON syntax is parsed, extract the stat_list specific
    // data.
    this->read_from_json_structure(json_root);
    
}

void item_quantities_t::read_from_json_structure(const Json::Value& json_root)
{
    
    // Parse root
    if (!json_root.isArray())
        throw error_message_t(error_code_t::JSON_SCHEMA_VIOLATION, "Error.  Root of item_quantities is not of type \"array\".");
    
    this->materials_list_.reserve(json_root.size());
    
    for (const Json::Value& json_cur_array_element : json_root)
    {
        item_quantity_t new_item_quantity;
        new_item_quantity.read_from_json_structure(json_cur_array_element);
        materials_list_.emplace_back(std::move(new_item_quantity));
    }
    
}

void item_quantities_t::write_to_json_file(std::ostream& file, unsigned indent_start, unsigned spaces_per_tab) const
{
    std::string buffer;
    this->write_to_json_buffer(buffer, indent_start, spaces_per_tab);
    file << buffer;
    if (!file.good())
        throw error_message_t(error_code_t::FILE_WRITE_FAILED, "Error.  Failed to write file when encoding item_quantities_t object.");
}

void item_quantities_t::write_to_json_buffer(std::string& buffer, unsigned indent_start, unsigned spaces_per_tab) const
{
    
    std::string indent_1(indent_start + 1 * spaces_per_tab, ' ');
    std::string_view indent_0(indent_1.data(), indent_start);
    
    unsigned num_materials = this->materials_list_.size();
    if (num_materials == 0)
    {
        
        buffer += "[]";
        
    } else {
        
        buffer += "[\n";
        buffer += indent_1;
        
        for (unsigned ix = 0, last_ix = num_materials - 1; ix <= last_ix; ix++)
        {
            
            this->materials_list_[ix].write_to_json_buffer(buffer, indent_start + spaces_per_tab, spaces_per_tab);
            
            if (ix == last_ix)
                buffer += '\n';
            else
                buffer += ", ";
            
        }
        
        buffer += indent_0;
        buffer += ']';
        
    }
    
}

std::istream& operator>>(std::istream& stream, item_quantities_t& destination)
{
    try
    {
        destination.read_from_json_file(stream);
    } catch (const error_message_t& error) {
        stream.setstate(std::ios::failbit);
        throw error;
    } catch (const Json::Exception& error) {
        stream.setstate(std::ios::failbit);
        throw error;
    }
    return stream;
}

