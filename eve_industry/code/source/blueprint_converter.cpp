/// @file blueprint_converter.cpp
/// Program entry point for blueprint_converter utility.
///
/// * Contact conor.gardner@arm.com if you have questions about this code.
/// * Date Created = Wednesday December 6 2017
/// * Documentation is generated by doxygen, see html/index.html

#include <fstream>
#include <iostream>
#include <unordered_map>

#include "args_blueprint_converter.h"
#include "blueprints.h"
#include "error.h"
#include "yaml-cpp/yaml.h"

// Generates a mapping of T2 blueprints to the T1 blueprint they were invented
// from.
std::unordered_map<uint64_t, uint64_t> generate_invention_back_map(const YAML::Node& ccp_yaml_in)
{
    
    // Validate top-level node type
    if (!ccp_yaml_in.IsMap())
        throw error_message_t(error_code_t::YAML_SCHEMA_VIOLATION, "Error.  ccp_yaml_in was not of type \"map\".");
    
    // Initial allocation for return value
    std::unordered_map<uint64_t, uint64_t> invention_back_map;
    
    // Iterate through each input blueprint
    for (YAML::const_iterator cur_node = ccp_yaml_in.begin(), end = ccp_yaml_in.end(); cur_node != end; cur_node++)
    {
        
        // Decode ID of current T1 blueprint
        const YAML::Node& yaml_cur_blueprint_id = cur_node->first;
        if (!yaml_cur_blueprint_id.IsScalar())
            throw error_message_t(error_code_t::YAML_SCHEMA_VIOLATION, "Error, key in blueprint map was not a scalar");
        uint64_t cur_blueprint_id = yaml_cur_blueprint_id.as<uint64_t>();
        
        // Parse YAML root
        const YAML::Node& yaml_cur_blueprint_root = cur_node->second;
        if (!yaml_cur_blueprint_root.IsMap())
        {
            std::cerr << "Warning.  Blueprint " << cur_blueprint_id << " was not of type \"map\".  Skipping.\n";
            continue;
        }
        
        // Parse YAML root -> activities
        const YAML::Node& yaml_cur_blueprint_activities = yaml_cur_blueprint_root["activities"];
        if (!yaml_cur_blueprint_activities.IsDefined())
        {
            std::cerr << "Warning.  Blueprint " << cur_blueprint_id << " did not contain key \"activities\".  Skipping.\n";
            continue;
        } else if (!yaml_cur_blueprint_activities.IsMap()) {
            std::cerr << "Warning.  Blueprint " << cur_blueprint_id << "->activities was not of type \"map\".  Skipping.\n";
            continue;
        }
        
        // Parse YAML root -> activities -> invention
        const YAML::Node& yaml_cur_blueprint_invention = yaml_cur_blueprint_activities["invention"];
        if (!yaml_cur_blueprint_invention.IsDefined())
            continue; // Blueprint cannot be invented
        if (!yaml_cur_blueprint_invention.IsMap())
        {
            std::cerr << "Warning.  Blueprint " << cur_blueprint_id << "->activities->invention was not of type \"map\".  Skipping.\n";
            continue;
        }
        
        // Parse YAML root -> activities -> invention -> products
        const YAML::Node& yaml_cur_blueprint_products = yaml_cur_blueprint_invention["products"];
        if (!yaml_cur_blueprint_products.IsDefined())
        {
            std::cerr
             << "Warning.  Blueprint "
             << cur_blueprint_id
             << "->activities->invention did not contain key \"products\".  Skipping.\n";
            continue;
        } else if (!yaml_cur_blueprint_products.IsSequence()) {
            std::cerr
             << "Warning.  Blueprint "
             << cur_blueprint_id
             << "->activities->invention->products was not of type \"sequence\".  Skipping.\n";
             continue;
        }
        
        // Iterate through each output product
        unsigned product_ix = 0;
        for (const YAML::Node& yaml_cur_product : yaml_cur_blueprint_products)
        {
            
            if (!yaml_cur_product.IsMap())
            {
                std::cerr
                 << "Warning.  Blueprint "
                 << cur_blueprint_id
                 << "->activities->invention->products["
                 << product_ix
                 << "] was not of type \"map\".  Skipping.\n";
                continue;
            }
            
            // Parse  YAML root -> activities -> invention -> products[product_ix] -> typeID
            const YAML::Node yaml_cur_product_type_id = yaml_cur_product["typeID"];
            if (!yaml_cur_product_type_id.IsDefined())
            {
                std::cerr
                 << "Warning.  Blueprint "
                 << cur_blueprint_id
                 << "->activities->invention->products["
                 << product_ix
                 << "] did not contain key \"typeID\".";
                continue;
            }
            uint64_t invented_blueprint_id = yaml_cur_product_type_id.as<uint64_t>();
            
            // Create new mapping in the return value
            invention_back_map[invented_blueprint_id] = cur_blueprint_id;
            
            product_ix++;
            
        }
        
    }
    
    return invention_back_map;
    
}

/// @brief Copy fields from a YAML array to an item quantities structure.
///
/// @return True if all elements in input array were parsed successfully. If 
/// false is returned, then the output item_quantities may be full of garbage.
bool convert_item_quantities
(
    const YAML::Node& input_array,
    item_quantities_t& output
){
    
    if (!input_array.IsDefined())
        return false;
    else if (!input_array.IsSequence())
        return false;
    
    // Clear output storage
    std::vector<item_quantity_t>& output_storage = output.materials_list();
    output_storage.clear();
    
    for (const YAML::Node& yaml_cur_item_quantity : input_array)
    {
        
        if (!yaml_cur_item_quantity.IsMap())
            return false;
        
        item_quantity_t new_item_quantity;
        
        // Parse input_array[ix] -> typeID
        const YAML::Node& yaml_cur_item_id = yaml_cur_item_quantity["typeID"];
        if (!yaml_cur_item_id.IsDefined())
            return false;
        else if (!yaml_cur_item_id.IsScalar())
            return false;
        new_item_quantity.item_id(yaml_cur_item_id.as<uint64_t>());
        
        // Parse input_array[ix] -> quantity
        const YAML::Node& yaml_cur_quantity = yaml_cur_item_quantity["quantity"];
        if (!yaml_cur_quantity.IsDefined())
            return false;
        else if (!yaml_cur_quantity.IsScalar())
            return false;
        new_item_quantity.quantity(yaml_cur_quantity.as<uint64_t>());
        
        // Commit new array element
        output_storage.emplace_back(std::move(new_item_quantity));
        
    }
    
    return true;
    
}

/// @brief Copy fields from a YAML blueprint to eve_industry's blueprint format.
///
/// @return True if the output blueprint was written successfully.  If false
/// is returned, then the output_blueprint may be full of garbage.
bool convert_blueprint
(
    const YAML::const_iterator& input_blueprint,
    const YAML::Node& all_blueprints,
    const std::unordered_map<uint64_t, uint64_t>& invention_back_map,
    blueprint_t& output_blueprint
){
    
    blueprint_t::manufacture_t& manufacture = output_blueprint.manufacture();
    blueprint_t::copy_t& copy = output_blueprint.copy();
    blueprint_t::invent_t& invent = output_blueprint.invent();
    copy.valid(true);
    invent.valid(false);
    
    // Decode ID of current T1 blueprint
    const YAML::Node& yaml_cur_blueprint_id = input_blueprint->first;
    if (!yaml_cur_blueprint_id.IsScalar())
    {
        std::cerr << "Error, key in blueprint map was not a scalar.\n";
        return false;
    }
    uint64_t cur_blueprint_id = yaml_cur_blueprint_id.as<uint64_t>();
    output_blueprint.blueprint_id(cur_blueprint_id);
    
    // Parse YAML root
    const YAML::Node& yaml_cur_blueprint_root = input_blueprint->second;
    if (!yaml_cur_blueprint_root.IsMap())
    {
        std::cerr << "Warning.  Blueprint " << cur_blueprint_id << " was not of type \"map\".  Skipping.\n";
        return false;
    }
    
    // Parse YAML root -> activities
    const YAML::Node& yaml_cur_blueprint_activities = yaml_cur_blueprint_root["activities"];
    if (!yaml_cur_blueprint_activities.IsDefined())
    {
        std::cerr << "Warning.  Blueprint " << cur_blueprint_id << " did not contain key \"activities\".  Skipping.\n";
        return false;
    } else if (!yaml_cur_blueprint_activities.IsMap()) {
        std::cerr << "Warning.  Blueprint " << cur_blueprint_id << "->activities was not of type \"map\".  Skipping.\n";
        return false;
    }
    
    //----- Begin parsing manufacture_t sub-structure -----///
    
    // Parse YAML root -> activities -> manufacture
    const YAML::Node& yaml_cur_blueprint_manufacture = yaml_cur_blueprint_activities["manufacturing"];
    if (!yaml_cur_blueprint_manufacture.IsDefined())
    {
        std::cerr << "Warning.  Blueprint " << cur_blueprint_id << "->activities did not contain key \"manufacturing\".  Skipping.\n";
        return false;
    } else if (!yaml_cur_blueprint_manufacture.IsMap()) {
        std::cerr << "Warning.  Blueprint " << cur_blueprint_id << "->activities->manufacturing was not of type \"map\".  Skipping.\n";
        return false;
    }
    
    // Parse YAML root -> activities -> manufacture -> time
    const YAML::Node& yaml_cur_manufacture_time = yaml_cur_blueprint_manufacture["time"];
    if (!yaml_cur_manufacture_time.IsDefined())
    {
        std::cerr << "Warning.  Blueprint " << cur_blueprint_id << "->activities->manufacturing did not contain key \"time\".  Skipping.\n";
        return false;
    } else if (!yaml_cur_manufacture_time.IsScalar()) {
        std::cerr << "Warning.  Blueprint " << cur_blueprint_id << "->activities->manufacturing->time was not of type \"scalar\".  Skipping.\n";
        return false;
    }
    manufacture.time(yaml_cur_manufacture_time.as<uint64_t>());
    
    // Parse YAML root -> activities -> manufacture -> materials
    const YAML::Node& yaml_cur_manufacture_materials = yaml_cur_blueprint_manufacture["materials"];
    if (!yaml_cur_manufacture_materials.IsDefined())
    {
        std::cerr << "Warning.  Blueprint " << cur_blueprint_id << "->activities->manufacturing did not contain key \"materials\".  Skipping.\n";
        return false;
    } else if (!convert_item_quantities(yaml_cur_manufacture_materials, manufacture.input_materials())) {
        std::cerr << "Warning.  Blueprint " << cur_blueprint_id << "->activities->manufacturing->materials could not be parsed.  Skipping.\n";
        return false;
    }
    
    // Parse YAML root -> activities -> manufacture -> products
    const YAML::Node& yaml_cur_manufacture_products = yaml_cur_blueprint_manufacture["products"];
    if (!yaml_cur_manufacture_products.IsDefined())
    {
        std::cerr << "Warning.  Blueprint " << cur_blueprint_id << "->activities->manufacturing did not contain key \"products\".  Skipping.\n";
        return false;
    } else if (!convert_item_quantities(yaml_cur_manufacture_products, manufacture.output_materials())) {
        std::cerr << "Warning.  Blueprint " << cur_blueprint_id << "->activities->manufacturing->products could not be parsed.  Skipping.\n";
        return false;
    }
    
    const std::unordered_map<uint64_t, uint64_t>::const_iterator cur_invention_dependency = invention_back_map.find(cur_blueprint_id);
    bool cur_blueprint_is_t2 = cur_invention_dependency != invention_back_map.end();
    if (cur_blueprint_is_t2)
    {
        // If this is a T2 blueprint then set ME/TE to 2/4.
        manufacture.material_efficiency(2);
        manufacture.time_efficiency(4);
    } else {
        // If this is a T1 blueprint then set ME/TE to 10/20.
        manufacture.material_efficiency(10);
        manufacture.time_efficiency(20);
    }
    
    //----- Begin parsing copy_t sub-structure -----///
    
    // Parse YAML root -> activities -> copying
    const YAML::Node& yaml_cur_blueprint_copying = yaml_cur_blueprint_activities["copying"];
    if (yaml_cur_blueprint_copying.IsDefined())
    {
        
        // Parse YAML root -> activities -> copying -> time
        const YAML::Node& yaml_cur_copying_time = yaml_cur_blueprint_copying["time"];
        if (!yaml_cur_copying_time.IsDefined())
        {
            std::cerr << "Warning.  Blueprint " << cur_blueprint_id << "->activities->copying did not contain key \"time\".  Skipping.\n";
            return false;
        } else if (!yaml_cur_copying_time.IsScalar()) {
            std::cerr << "Warning.  Blueprint " << cur_blueprint_id << "->activities->copying->time was not of type \"scalar\".  Skipping.\n";
            return false;
        }
        copy.time(yaml_cur_copying_time.as<uint64_t>());
        
        // Parse Optional YAML root -> activities -> copying -> materials
        const YAML::Node& yaml_cur_copying_materials = yaml_cur_blueprint_copying["materials"];
        if (yaml_cur_copying_materials.IsDefined())
        {
            if (!convert_item_quantities(yaml_cur_copying_materials, copy.input_materials()))
            {
                std::cerr << "Warning.  Blueprint " << cur_blueprint_id << "->activities->copying->materials could not be parsed.  Skipping.\n";
                return false;
            }
        } else {
            copy.input_materials().materials_list().clear();
        }
        
        copy.valid(true);
        
    }
    
    //----- Begin parsing invent_t sub-structure -----///
    
    if (cur_blueprint_is_t2)
    {
        
        // Search YAML input for the T1 blueprint used to invent this blueprint
        // The input YAML attaches invention info on the input T1 blueprint
        // The output JSON attaches invention info on the output T2 blueprint
        uint64_t cur_t1_id = cur_invention_dependency->second;
        const YAML::Node& yaml_cur_t1_input_root = all_blueprints[cur_t1_id];
        if (!yaml_cur_t1_input_root.IsDefined())
        {
            std::cerr
             << "Error.  Could not find T1 blueprint with ID "
             << cur_t1_id
             << " required to invent T2 blueprint with ID "
             << cur_blueprint_id
             << ".\n";
            return false;
        }
        invent.invented_from_blueprint_id(cur_t1_id);
        
        // Parse YAML T1 -> activities
        const YAML::Node& yaml_cur_t1_input_activities = yaml_cur_t1_input_root["activities"];
        if (!yaml_cur_t1_input_activities.IsDefined())
        {
            std::cerr
             << "Warning.  Blueprint T1 blueprint "
             << cur_t1_id
             << " required to invent T2 blueprint "
             << cur_blueprint_id
             << " did not contain field \"activities\".  Skipping T2.\n";
            return false;
        } else if (!yaml_cur_t1_input_activities.IsMap()) {
            std::cerr
             << "Warning.  Blueprint T1 blueprint "
             << cur_t1_id
             << "->activities required to invent T2 blueprint "
             << cur_blueprint_id
             << "was not of type \"map\".  Skipping T2.\n";
            return false;
        }
        
        // Parse YAML T1 -> activities -> invention
        const YAML::Node& yaml_cur_t1_input_invention = yaml_cur_t1_input_activities["invention"];
        if (!yaml_cur_t1_input_invention.IsDefined())
        {
            std::cerr
             << "Warning.  Blueprint T1 blueprint "
             << cur_t1_id
             << " required to invent T2 blueprint "
             << cur_blueprint_id
             << " did not contain field \"activities->invention\".  Skipping T2.\n";
            return false;
        } else if (!yaml_cur_t1_input_invention.IsMap()) {
            std::cerr
             << "Warning.  Blueprint T1 blueprint "
             << cur_t1_id
             << "->activities->invention required to invent T2 blueprint "
             << cur_blueprint_id
             << "was not of type \"map\".  Skipping T2.\n";
            return false;
        }
        
        // Parse YAML T1 -> activities -> invention -> time
        const YAML::Node& yaml_cur_t1_input_time = yaml_cur_t1_input_invention["time"];
        if (!yaml_cur_t1_input_time.IsDefined())
        {
            std::cerr
             << "Warning.  Blueprint T1 blueprint "
             << cur_t1_id
             << " required to invent T2 blueprint "
             << cur_blueprint_id
             << " did not contain field \"activities->invention->time\".  Skipping T2.\n";
            return false;
        } else if (!yaml_cur_t1_input_time.IsScalar()) {
            std::cerr
             << "Warning.  Blueprint T1 blueprint "
             << cur_t1_id
             << "->activities->invention->time required to invent T2 blueprint "
             << cur_blueprint_id
             << "was not of type \"scalar\".  Skipping T2.\n";
            return false;
        }
        invent.time(yaml_cur_t1_input_time.as<uint64_t>());
        
        // Parse YAML T1 -> activities -> invention -> materials
        const YAML::Node& yaml_cur_t1_input_materials = yaml_cur_t1_input_invention["materials"];
        if (!yaml_cur_t1_input_materials.IsDefined())
        {
            std::cerr
             << "Warning.  Blueprint T1 blueprint "
             << cur_t1_id
             << " required to invent T2 blueprint "
             << cur_blueprint_id
             << " did not contain field \"activities->invention->materials\".  Skipping T2.\n";
            return false;
        } else if (!convert_item_quantities(yaml_cur_t1_input_materials, invent.input_materials())) {
            std::cerr
             << "Warning.  Blueprint T1 blueprint "
             << cur_t1_id
             << " required to invent T2 blueprint "
             << cur_blueprint_id
             << " did not contain field \"activities->invention->materials\" could not be parsed.  Skipping T2.\n";
        }
        
        // Base ME and TE are constant for all blueprints
        invent.material_efficiency(2);
        invent.time_efficiency(4);
        
        // Parse YAML root -> maxProductionLimit
        const YAML::Node& yaml_cur_blueprint_max_production_limit = yaml_cur_blueprint_root["maxProductionLimit"];
        if (!yaml_cur_blueprint_max_production_limit.IsDefined())
        {
            std::cerr << "Warning.  Blueprint " << cur_blueprint_id << " did not contain key \"maxProductionLimit\".  Skipping.\n";
            return false;
        } else if (!yaml_cur_blueprint_max_production_limit.IsScalar()) {
            std::cerr << "Warning.  Blueprint " << cur_blueprint_id << "->maxProductionLimit was not of type \"scalar\".  Skipping.\n";
            return false;
        }
        invent.runs(yaml_cur_blueprint_max_production_limit.as<uint64_t>());
        
        // Parse YAML T1 -> activities -> invention -> products
        const YAML::Node& yaml_cur_t1_input_products = yaml_cur_t1_input_invention["products"];
        if (!yaml_cur_t1_input_products.IsDefined())
        {
            std::cerr
             << "Warning.  Blueprint T1 blueprint "
             << cur_t1_id
             << " required to invent T2 blueprint "
             << cur_blueprint_id
             << " did not contain field \"activities->invention->products\".  Skipping T2.\n";
            return false;
        } else if (!yaml_cur_t1_input_products.IsSequence()) {
            std::cerr
             << "Warning.  Blueprint T1 blueprint "
             << cur_t1_id
             << "->activities->invention->products required to invent T2 blueprint "
             << cur_blueprint_id
             << "was not of type \"sequence\".  Skipping T2.\n";
            return false;
        }
        
        bool probability_found = false;
        
        // Find YAML T1 -> activities -> invention -> products[cur_blueprint_id]
        unsigned product_ix = 0;
        for (const YAML::Node& yaml_cur_product : yaml_cur_t1_input_products)
        {
            
            // Parse  YAML root -> activities -> invention -> products[product_ix]
            if (!yaml_cur_product.IsMap())
            {
                std::cerr
                 << "Warning.  Blueprint T1 blueprint "
                 << cur_t1_id
                 << "activities->invention->products["
                 << product_ix
                 << "] required to invent T2 blueprint "
                 << cur_blueprint_id
                 << " was not of type \"map\".  Skipping.\n";
                continue;
            }
            
            // Parse  YAML root -> activities -> invention -> products[product_ix] -> typeID
            const YAML::Node yaml_cur_product_type_id = yaml_cur_product["typeID"];
            if (!yaml_cur_product_type_id.IsDefined())
            {
                std::cerr
                 << "Warning.  Blueprint T1 blueprint "
                 << cur_t1_id
                 << "activities->invention->products["
                 << product_ix
                 << "] required to invent T2 blueprint "
                 << cur_blueprint_id
                 << " did not contain key \"typeID\".  Skipping.\n";
                continue;
            }
            uint64_t invented_blueprint_id = yaml_cur_product_type_id.as<uint64_t>();
            
            if (invented_blueprint_id == cur_blueprint_id)
            {
                
                // Parse  YAML root -> activities -> invention -> products[product_ix] -> probability
                const YAML::Node& yaml_cur_probability = yaml_cur_product["probability"];
                if (!yaml_cur_probability.IsDefined())
                {
                    std::cerr
                     << "Warning.  Blueprint T1 blueprint "
                     << cur_t1_id
                     << " required to invent T2 blueprint "
                     << cur_blueprint_id
                     << " did not contain field \"activities->invention->products["
                     << cur_blueprint_id
                     << "]->probability\".  Skipping T2.\n";
                    return false;
                } else if (!yaml_cur_probability.IsScalar()) {
                    std::cerr
                     << "Warning.  Blueprint T1 blueprint "
                     << cur_t1_id
                     << "->activities->invention->products["
                     << cur_blueprint_id
                     << "] required to invent T2 blueprint "
                     << cur_blueprint_id
                     << "was not of type \"scalar\".  Skipping T2.\n";
                    return false;
                }
                invent.probability(yaml_cur_probability.as<float>());
                probability_found = true;
                break;
                
            }
            
            product_ix++;
            
        }
        if (!probability_found)
        {
            std::cerr
             << "Warning.  Blueprint T1 blueprint "
             << cur_t1_id
             << "->activities->invention->products did not contain element with typeID"
             << cur_blueprint_id
             << "] required to invent T2 blueprint "
             << cur_blueprint_id
             << "was not of type \"scalar\".  Skipping T2.\n";
            return false;
        }
        
        invent.valid(true);
        
    }
    
    return true;
    
}

int main(int argc, char** argv)
{
    
    try
    {
        
        // Parse command line arguments
        args::blueprint_converter_t args;
        args.parse(argc, argv);
        
        // Parse input file
        YAML::Node ccp_yaml_in = YAML::LoadFile(args.ccp_yaml_in());
        
        // Calculate invention dependencies
        const std::unordered_map<uint64_t, uint64_t> invention_back_map = generate_invention_back_map(ccp_yaml_in);
        
        blueprints_t blueprints_out;
        
        // Iterate through each YAML input blueprint
        unsigned failure_count = 0;
        for (YAML::const_iterator cur_node = ccp_yaml_in.begin(), end = ccp_yaml_in.end(); cur_node != end; cur_node++)
        {
            blueprint_t new_blueprint;
            if (convert_blueprint(cur_node, ccp_yaml_in, invention_back_map, new_blueprint))
                blueprints_out.add_blueprint(std::move(new_blueprint));
            else
                failure_count++;
        }
        
        std::cerr << failure_count << " blueprints failed.  " << blueprints_out.storage().size() << " succeeded.\n";
        
        // Write output blueprints file
        std::ofstream custom_json_out_file(args.custom_json_out());
        if (!custom_json_out_file.good())
        {
            std::cerr << "Error.  Failed to open \"" << args.custom_json_out() << "\" for writing.\n";
            return -1;
        }
        custom_json_out_file << blueprints_out;
        
    } catch (const error_message_t& error) {
        
        std::cout << error.message() << '\n';
        
    }
    
    return 0;
    
}

