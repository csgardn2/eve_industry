/// @file id_vector.h
/// @brief Declaration of @ref id_vector_t class
/// 
/// * Contact conor.gardner@arm.com if you have questions about this code.
/// * Date Created = Saturday October 21 2017
/// * Documentation is generated by doxygen, see html/index.html

#ifndef HEADER_GUARD_ID_VECTOR
#define HEADER_GUARD_ID_VECTOR

#include <fstream>
#include <iostream>
#include <memory>
#include <string_view>
#include <vector>

#include "error.h"
#include "https_get.h"
#include "json.h"

/// @brief Generic class for fetching and storing a list of valid integral
/// uniquifiers from the EvE Swagger API.
template
<
    /// The base URL to fetch ids from.
    /// Example: https://esi.tech.ccp.is/latest/universe/types/?datasource=tranquility
    char const* url
>
/// @brief List of integral uniquifiers used by inventory items in the EvE
/// universe.  These are only the IDs, not the attributes for any items.
class id_vector_t : public std::vector<unsigned>
{
        
    protected:
        
        /// @brief String representations of enumeration symbols.
        static const std::vector<std::string_view> error_names_;
        
        /// @brief Default error messages suitable for printing.  Note that
        /// some of these are inherently vague without additional information.
        static const std::vector<std::string_view> default_error_messages_;
        
        // Try to make all your members protected, even if they don't
        // really need to be.
        
    public:
        
        /// @brief Error codes are defined to facilitate programmatic detection and
        /// correction.
        enum class error_code_t
        {
            FILE_SIZE_FAILED,
            FILE_READ_FAILED,
            FILE_WRITE_FAILED,
            JSON_SCHEMA_VIOLATION,
            EVE_SUCKS,
            /// This element must be last
            NUM_ENUMS
        };
        
        typedef error_message_template_t
        <
            error_code_t,
            error_names_,
            default_error_messages_
        > error_message_t;
        
        /// @brief Default constructor
        inline id_vector_t() = default;
        
        /// @brief Copy constructor
        inline id_vector_t(const id_vector_t& source) = default;
        
        /// @brief Move constructor
        inline id_vector_t(id_vector_t&& source) = default;
        
        // Add member initialization constructors here
        // Try to use initializer lists when possible.
        
        /// See @ref decode(std::istream& file)
        ///
        /// @exception error_message_t
        /// @exception Json::Exception
        inline id_vector_t(std::istream& file)
        {
            this->decode(file);
        }
        
        /// @brief See @ref decode(std::istream& file)
        ///
        /// @exception error_message_t
        /// @exception Json::Exception
        inline id_vector_t(std::string_view buffer)
        {
            this->decode(buffer);
        }
        
        /// @brief See @ref decode(const Json::Value& json_root)
        ///
        /// @exception error_message_t
        inline id_vector_t(const Json::Value& json_root)
        {
            this->decode(json_root);
        }
        
        /// @brief Destructor
        inline ~id_vector_t() = default;
        
        /// @brief Assignment operator with deep copy.
        inline id_vector_t& operator=(const id_vector_t& source) = default;
        
        /// @brief Assignment operator with shallow copy.
        inline id_vector_t& operator=(id_vector_t&& source) = default;
        
        /// @brief See @ref decode(std::istream& file)
        ///
        /// @exception error_message_t
        /// @exception Json::Exception
        inline id_vector_t& operator=(std::istream& file)
        {
            this->decode(file);
            return *this;
        }
        
        /// @brief See @ref decode(std::string_view buffer)
        ///
        /// @exception error_message_t
        /// @exception Json::Exception
        inline id_vector_t& operator=(std::string_view buffer)
        {
            this->decode(buffer);
            return *this;
        }
        
        /// @brief See @ref decode(const Json::Value& json_root)
        ///
        /// @exception error_message_t
        inline id_vector_t& operator=(const Json::Value& json_root)
        {
            this->decode(json_root);
            return *this;
        }
        
        // Add operator[] here if desired.
        // inline type operator[](unsigned ix) const;
        // inline type& operator[](unsigned ix);
        
        // Add member read and write functions
        // inline type member() const;
        // inline void member(const type& t);
        
        /// @brief Pull as many item IDs from the EvE API as possible.  All
        /// previous content is cleared.
        void fetch()
        {
            
            // Since this class is a template, we need to declare all functions
            // including long ones in the header.  Note that this won't introduce
            // compile-time bloat, since nothing is compiled until you actually
            // instantiate the template.
            
            this->clear();
            
            // Automatically de-allocate memory when this function returns or throws
            // an error.
            Json::CharReaderBuilder builder;
            std::unique_ptr<Json::CharReader> reader(builder.newCharReader());
            
            std::string progress_message;
            
            // There are multiple pages of item IDs.  The last page is signified with
            // and empty array.
            std::string query_prefix(url);
            query_prefix += "&page=";
            unsigned page = 1;
            while (true)
            {
                
                // Print progress message, erasing previous one if it existed
                for (unsigned ix = 0, bound = progress_message.length(); ix < bound; ix++)
                    std::cout << '\b';
                progress_message = "Page ";
                progress_message += std::to_string(page);
                std::cout << progress_message << std::flush;
                
                // Prepare a request URL
                std::string query(query_prefix);
                query += std::to_string(page);
                page++;
                
                // Attempt to pull data from the EVE API
                std::string payload = https_get(query);
                
                // Attempt to decode received data
                Json::Value json_item_ids;
                std::string error_message;
                if (!reader->parse(payload.data(), payload.data() + payload.size(), &json_item_ids, &error_message))
                {
                    std::string message("Error.  Tried to decode JSON data from\"");
                    message += query;
                    message += "\" but it failed with message \"";
                    message += error_message;
                    message += "\".\n";
                    throw error_message_t(error_code_t::EVE_SUCKS, message);
                }
                
                // Append fetched data to internal storage
                unsigned old_size = this->size();
                unsigned new_size = old_size + json_item_ids.size();
                this->resize(new_size);
                for
                (
                    unsigned read_ix = 0, write_ix = old_size;
                    write_ix < new_size;
                    read_ix++, write_ix++
                ){
                    
                    const Json::Value& json_cur_element = json_item_ids[read_ix];
                    
                    if (!json_cur_element.isUInt())
                    {
                        std::string message("Error.  Element ");
                        message += std::to_string(read_ix);
                        message += " fetched from \"";
                        message += query;
                        message += "\" was not of type \"unsigned int\"\n";
                        throw error_message_t(error_code_t::EVE_SUCKS, message);
                    }
                    
                    (*this)[write_ix] = json_cur_element.asUInt();
                    
                }
                
                if (json_item_ids.empty())
                {
                    std::cout << '\n';
                    return;
                }
                
            }
            
        }
        
        /// @brief Open a file conforming to schema.json and use it to initialize
        /// this object, clearing previous content.
        ///
        /// @exception error_message_t
        /// @exception Json::Exception
        void decode(std::istream& file)
        {
            
            // Get the number of characters in the input file.
            if (!file.good())
                throw error_message_t(error_code_t::FILE_SIZE_FAILED);
            file.seekg(0, std::ios_base::end);
            unsigned file_size = file.tellg();
            file.seekg(0, std::ios_base::beg);
            
            // Read the entire file into RAM at once
            std::string buffer(file_size, '\0');
            file.read(buffer.data(), file_size);
            if (!file.good())
                throw error_message_t(error_code_t::FILE_READ_FAILED);
            this->decode(std::string_view(buffer));
            
        }
        
        /// @brief Decode serialized content conforming to schema.json and use it
        /// to initialize this object, clearing previous content.
        ///
        /// @exception error_message_t
        /// @exception Json::Exception
        void decode(std::string_view buffer)
        {
            
            Json::CharReaderBuilder builder;
            Json::CharReader* reader = builder.newCharReader();
            
            Json::Value json_root;
            std::string error_message;
            bool success = reader->parse(buffer.begin(), buffer.end(), &json_root, &error_message);
            delete reader;
            if (!success)
                Json::throwRuntimeError(error_message);
            
            // Now that the JSON syntax is parsed, extract the stat_list specific
            // data.
            this->decode(json_root);
            
        }
        
        /// @brief Extract required data fields from a pre-parsed JSON tree
        /// and use them to initialize this object, clearing previous content.
        ///
        /// @exception error_message_t
        void decode(const Json::Value& json_root)
        {
            
            // Parse root
            if (!json_root.isArray())
                throw error_message_t(error_code_t::JSON_SCHEMA_VIOLATION, "Error.  Root of <item_ids> is not of type \"array\".\n");
            
            // Allocate memory
            unsigned size = json_root.size();
            this->clear();
            this->resize(size);
            
            // Copy each ID
            for (unsigned ix = 0; ix < size; ix++)
            {
                
                const Json::Value& json_cur_element = json_root[ix];
                if (!json_cur_element.isUInt())
                {
                    std::string message("Error.  <item_ids>[");
                    message += std::to_string(ix);
                    message += "] was not of type \"unsigned int\".\n";
                    throw error_message_t(error_code_t::JSON_SCHEMA_VIOLATION, message);
                }
                
                (*this)[ix] = json_cur_element.asUInt();
                
            }
            
        }
        
        /// @brief Serialize the content of this file into a file that
        /// conforms to the schema schema.json.
        void encode
        (
            
            /// [out] Stream to append serialized object content to.
            std::ostream& file,
            /// [in] The number of space ' ' characters to prepend to each line
            /// in the serialized output.
            unsigned indent_start = 0,
            /// [in] The number of additional spaces ' ' on top of indent_start
            /// to prepend to each line in the serialized output for each
            /// additional level of nesting.
            ///
            /// Indentation typically increases after each opening bracket '['
            /// or brace '{' and decreases after each closing bracket ']' or
            /// brace '}'.
            unsigned spaces_per_tab = 4
            
        ) const {
            
            file << this->encode(indent_start, spaces_per_tab);
            if (!file.good())
                throw error_message_t(error_code_t::FILE_WRITE_FAILED);
            
        }
        
        /// @brief Serialize the content of this file into a string that
        /// conforms to the schema schema.json.
        ///
        /// @exception error_message_t
        void encode
        (
            /// [out] This string is overwritten with serialzed JSON content.
            std::string& buffer,
            /// [in] The number of space ' ' characters to prepend to each line
            /// in the serialized output.
            unsigned indent_start = 0,
            /// [in] The number of additional spaces ' ' on top of indent_start
            /// to prepend to each line in the serialized output for each
            /// additional level of nesting.
            ///
            /// Indentation typically increases after each opening bracket '['
            /// or brace '{' and decreases after each closing bracket ']' or
            /// brace '}'.
            unsigned spaces_per_tab = 4
        ) const {
            
            std::string indent_1(indent_start + spaces_per_tab, ' ');
            std::string_view indent_0(indent_1.data(), indent_start);
            
            // It is recommended not to start a new line before the opening brace, to
            // enable chaining.
            buffer += "[\n";
            
            // Encode member variables.
            for (signed ix = 0, last_ix = this->size() - 1; ix <= last_ix; ix++)
            {
                
                buffer += indent_1;
                buffer += std::to_string((*this)[ix]);
                
                if (ix != last_ix)
                    buffer += ',';
                buffer += '\n'; 
                
            }
            
            // It is recommended to not put a newline on the last brace to allow
            // comma chaining when this object is an element of an array.
            buffer += indent_0;
            buffer += "]";
            
        }
        
        /// @brief Convinence method for pretty initialize-on-construction
        /// syntax.
        inline std::string encode
        (
            /// [in] The number of space ' ' characters to prepend to each line
            /// in the serialized output.
            unsigned indent_start = 0,
            /// [in] The number of additional spaces ' ' on top of indent_start
            /// to prepend to each line in the serialized output for each
            /// additional level of nesting.
            ///
            /// Indentation typically increases after each opening bracket '['
            /// or brace '{' and decreases after each closing bracket ']' or
            /// brace '}'.
            unsigned spaces_per_tab = 4
        ) const {
            std::string buffer;
            this->encode(buffer, indent_start, spaces_per_tab);
            return buffer;
        }
        
};

/// @brief Convenience alias to allow printing directly via cout or similar.
template <const char* url>
inline std::ostream& operator<<(std::ostream& stream, typename id_vector_t<url>::error_code_t error_code)
{
    stream << id_vector_t<url>::error_message_t::enum_to_string(error_code);
    return stream;
}

/// @brief Convenience alias to allow printing directly via cout or similar.
template <const char* url>
inline std::ostream& operator<<(std::ostream& stream, const typename id_vector_t<url>::error_message_t& error_message)
{
    stream << error_message.message();
    return stream;
}

/// @brief Convenience alias to allow printing directly via cout or similar.
template <const char* url>
inline std::ostream& operator<<(std::ostream& stream, const id_vector_t<url>& source)
{
    stream << source.encode();
    return stream;
}

/// @brief Convenience alias to allow printing directly via cout or similar.
template <const char* url>
inline std::string& operator<<(std::string& buffer, const id_vector_t<url>& source)
{
    buffer += source.encode();
    return buffer;
}

/// @brief Extraction operator for decoding.
template <const char* url>
std::istream& operator>>(std::istream& stream, id_vector_t<url>& destination)
{
    try
    {
        destination.decode(stream);
    } catch (typename id_vector_t<url>::error_message_t error) {
        stream.setstate(std::ios::failbit);
        throw error;
    } catch (Json::Exception error) {
        stream.setstate(std::ios::failbit);
        throw error;
    }
    return stream;
}

/// @brief Extraction operator for decoding.
template <const char* url>
inline std::string_view operator>>(std::string_view& buffer, id_vector_t<url>& destination)
{
    destination.decode(buffer);
    return std::string_view();
}

/// @brief Extraction operator for decoding.
template <const char* url>
inline Json::Value operator>>(const Json::Value& json_root, id_vector_t<url>& destination)
{
    destination.decode(json_root);
    return Json::Value();
}

#endif // Header Guard

