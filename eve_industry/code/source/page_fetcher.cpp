/// @file page_fetcher.cpp
/// @brief Implementation of @ref page_fetcher_t class
/// 
/// * Contact conor.gardner@arm.com if you have questions about this code.
/// * Date Created = Thursday November 9 2017
/// * Documentation is generated by doxygen, see html/index.html

#include <atomic>
#include <fstream>
#include <iostream>
#include <mutex>
#include <string>
#include <string_view>
#include <thread>
#include <vector>

#include "page_fetcher.h"
#include "error.h"
#include "https_get.h"
#include "json.h"

void page_fetcher_t::erase_terminal()
{
    
    unsigned num_characters = this->last_print_length_;
    
    // Move cursor as far left as possible
    for (unsigned ix = 0; ix < num_characters; ix++)
        std::cout << '\b';
    
    // Overwrite characters with spaces
    for (unsigned ix = 0; ix < num_characters; ix++)
        std::cout << ' ';
    
    // Move cursor as far left as possible
    for (unsigned ix = 0; ix < num_characters; ix++)
        std::cout << '\b';
    
}

void page_fetcher_t::worker_function(std::vector<Json::Value>* output)
{
    
    // Create a JSON decoder
    Json::CharReaderBuilder builder;
    std::unique_ptr<Json::CharReader> reader(builder.newCharReader());
    
    // Hoisted to reduce re-allocations
    std::string query;
    std::string json_error_message;
    std::string progress_string;
    std::string raw_payload;
    
    /// Keep fetching until a worker identifies the last page
    while (!this->kill_switch_)
    {
        
        unsigned page = this->next_page_++;
        
        if (this->debug_mode_.verbose())
        {
            
            this->print_lock_.lock();
            
            this->erase_terminal();
            
            // Write new progress message
            progress_string = "Fetching market orders page ";
            progress_string += std::to_string(page);
            std::cout << progress_string << std::flush;
            this->last_print_length_ = progress_string.length();
            
            this->print_lock_.unlock();
            
        }
        
        // Fetch market data from network
        query = this->base_url_;
        query += "&page=";
        query += std::to_string(page);
        try
        {
            
            raw_payload = https_get(query);
            
        } catch (const error_message_t& error) {
            
            this->print_lock_.lock();
            this->erase_terminal();
            std::cout << "\nWarning.  Failed to fetch page " << page << error;
            this->print_lock_.unlock();
            
            this->kill_switch_ = true;
            return;
            
        }
        
        // Parse Json syntax of received string
        Json::Value json_payload;
        if (!reader->parse(raw_payload.data(), raw_payload.data() + raw_payload.size(), &json_payload, &json_error_message))
        {
            std::string message("Error.  Tried to decode JSON data from\"");
            message += query;
            message += "\" but it failed with message \"";
            message += json_error_message;
            message += "\".\n";
            throw error_message_t(error_code_t::EVE_SUCKS, message);
        }
        
        /// The last market page is indicated by an empty page.
        /// Exit this thread and signal other threads to quit.
        if (json_payload.empty())
        {
            this->kill_switch_ = true;
            return;
        }
        
        // Store parsed Json data to output vector
        this->output_lock_.lock();
        output->emplace_back(std::move(json_payload));
        this->output_lock_.unlock();
        
        // Decode JSON syntax of received data
        
        
    }
    
}

std::vector<Json::Value> page_fetcher_t::parallel_fetch(unsigned num_threads)
{
    
    // Reset thread control
    this->kill_switch_ = false;
    this->next_page_ = 1;
    this->output_lock_.unlock();
    this->print_lock_.unlock();
    
    std::vector<Json::Value> ret;
    
    // Spawn multiple threads to fetch pages of market data. 
    if (this->debug_mode_.verbose())
        std::cout << "Spawning " << num_threads << " worker threads for market page fetching.\n";
    std::vector<std::thread> workers;
    for (unsigned ix = 0; ix < num_threads; ix++)
        workers.emplace_back(&page_fetcher_t::worker_function, this, &ret);
    
    // Wait for all worker threads to finish.
    for (unsigned ix = 0; ix < num_threads; ix++)
        workers[ix].join();
    
    if (this->debug_mode_.verbose())
        std::cout << '\n';
    
    return ret;
    
}

void page_fetcher_t::read_from_json_file(std::istream& file)
{
    
    // Get the number of characters in the input file.
    if (!file.good())
        throw error_message_t(error_code_t::FILE_SIZE_FAILED, "Error.  Failed to determine file size when encoding page_fetcher_t object.\n");
    file.seekg(0, std::ios_base::end);
    unsigned file_size = file.tellg();
    file.seekg(0, std::ios_base::beg);
    
    // Read the entire file into RAM at once
    std::string buffer(file_size, '\0');
    file.read(buffer.data(), file_size);
    if (!file.good())
        throw error_message_t(error_code_t::FILE_READ_FAILED, "Error.  Failed to read file when decoding page_fetcher_t object.\n");
    this->read_from_json_buffer(std::string_view(buffer));
    
}

void page_fetcher_t::read_from_json_buffer(std::string_view buffer)
{
    
    Json::CharReaderBuilder builder;
    Json::CharReader* reader = builder.newCharReader();
    
    Json::Value json_root;
    std::string error_message;
    bool success = reader->parse(buffer.begin(), buffer.end(), &json_root, &error_message);
    delete reader;
    if (!success)
        Json::throwRuntimeError(error_message);
    
    // Now that the JSON syntax is parsed, extract the stat_list specific
    // data.
    this->read_from_json_json(json_root);
    
}

void page_fetcher_t::read_from_json_json(const Json::Value& json_root)
{
    
    // Parse root
    if (!json_root.isObject())
        throw error_message_t(error_code_t::JSON_SCHEMA_VIOLATION, "Error.  Root of TODO is not of type \"object\".\n");
    
    // TODO Decode the rest of your member variables here.
    
}

void page_fetcher_t::write_to_json_file(std::ostream& file, unsigned indent_start, unsigned spaces_per_tab) const
{
    file << this->write_to_json_buffer(indent_start, spaces_per_tab);
    if (!file.good())
        throw error_message_t(error_code_t::FILE_WRITE_FAILED, "Error.  Failed to write file when encoding page_fetcher_t object.\n");
}

void page_fetcher_t::write_to_json_buffer(std::string& buffer, unsigned indent_start, unsigned spaces_per_tab) const
{
    
    std::string indent_1(indent_start + 1 * spaces_per_tab, ' ');
    std::string_view indent_0(indent_1.data(), indent_start);
    // TODO Create as many indent levels as needed using string_view.
    
    // It is recommended not to start a new line before the opening brace, to
    // enable chaining.
    buffer += "{\n";
    
    // TODO Encode member variables.
    
    // It is recommended to not put a newline on the last brace to allow
    // comma chaining when this object is an element of an array.
    buffer += indent_0;
    buffer += '}';
    
}

std::istream& operator>>(std::istream& stream, page_fetcher_t& destination)
{
    try
    {
        destination.read_from_json_file(stream);
    } catch (const error_message_t& error) {
        stream.setstate(std::ios::failbit);
        throw error;
    } catch (const Json::Exception& error) {
        stream.setstate(std::ios::failbit);
        throw error;
    }
    return stream;
}

