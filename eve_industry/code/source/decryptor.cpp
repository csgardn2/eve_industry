/// @file decryptor.cpp
/// @brief Implementation of @ref decryptor_t class
/// 
/// * Contact conor.gardner@arm.com if you have questions about this code.
/// * Date Created = Wednesday November 29 2017
/// * Documentation is generated by doxygen, see html/index.html

#include <fstream>
#include <string>
#include <string_view>

#include "decryptor.h"
#include "error.h"
#include "json.h"

float decryptor_t::raw_probability_multiplier() const
{
    switch (this->type_)
    {
        case type_t::NO_DECRYPTOR:
            return 0.0f;
        case type_t::AUGMENTATION:
            return 0.6f;
        case type_t::OPTIMIZED_AUGMENTATION:
            return 0.9f;
        case type_t::SYMMETRY:
            return 1.0f;
        case type_t::PROCESS:
            return 1.1f;
        case type_t::ACCELERANT:
            return 1.2f;
        case type_t::PARITY:
            return 1.5f;
        case type_t::ATTAINMENT:
            return 1.8f;
        case type_t::OPTIMIZED_ATTAINMENT:
            return 1.9f;
        default:
            throw error_message_t(error_code_t::UNKNOWN_DECRYPTOR_TYPE, "Error.  Tried to determine probability modifier for invalid decryptor.\n");
    }
}

signed decryptor_t::raw_max_run_modifier() const
{
    switch (this->type_)
    {
        case type_t::NO_DECRYPTOR:
            return 0;
        case type_t::AUGMENTATION:
            return 9;
        case type_t::OPTIMIZED_AUGMENTATION:
            return 7;
        case type_t::SYMMETRY:
            return 2;
        case type_t::PROCESS:
            return 0;
        case type_t::ACCELERANT:
            return 1;
        case type_t::PARITY:
            return 3;
        case type_t::ATTAINMENT:
            return 4;
        case type_t::OPTIMIZED_ATTAINMENT:
            return 2;
        default:
            throw error_message_t(error_code_t::UNKNOWN_DECRYPTOR_TYPE, "Error.  Tried to determine max run modifier for invalid decryptor.\n");
    }
}

signed decryptor_t::raw_material_efficiency_modifier() const
{
    switch (this->type_)
    {
        case type_t::NO_DECRYPTOR:
            return 0;
        case type_t::AUGMENTATION:
            return -2;
        case type_t::OPTIMIZED_AUGMENTATION:
            return 2;
        case type_t::SYMMETRY:
            return 1;
        case type_t::PROCESS:
            return 3;
        case type_t::ACCELERANT:
            return 2;
        case type_t::PARITY:
            return 1;
        case type_t::ATTAINMENT:
            return -1;
        case type_t::OPTIMIZED_ATTAINMENT:
            return 1;
        default:
            throw error_message_t(error_code_t::UNKNOWN_DECRYPTOR_TYPE, "Error.  Tried to determine material efficiency modifier for invalid decryptor.\n");
    }
}

signed decryptor_t::raw_time_efficiency_modifier() const
{
    switch (this->type_)
    {
        case type_t::NO_DECRYPTOR:
            return 0;
        case type_t::AUGMENTATION:
            return 2;
        case type_t::OPTIMIZED_AUGMENTATION:
            return 0;
        case type_t::SYMMETRY:
            return 8;
        case type_t::PROCESS:
            return 6;
        case type_t::ACCELERANT:
            return 10;
        case type_t::PARITY:
            return -2;
        case type_t::ATTAINMENT:
            return 4;
        case type_t::OPTIMIZED_ATTAINMENT:
            return -2;
        default:
            throw error_message_t(error_code_t::UNKNOWN_DECRYPTOR_TYPE, "Error.  Tried to determine time efficiency modifier for invalid decryptor.\n");
    }
}

void decryptor_t::read_from_json_file(std::istream& file)
{
    
    // Get the number of characters in the input file.
    if (!file.good())
        throw error_message_t(error_code_t::FILE_SIZE_FAILED, "Error.  Failed to determine file size when encoding decryptor_t object.\n");
    file.seekg(0, std::ios_base::end);
    unsigned file_size = file.tellg();
    file.seekg(0, std::ios_base::beg);
    
    // Read the entire file into RAM at once
    std::string buffer(file_size, '\0');
    file.read(buffer.data(), file_size);
    if (!file.good())
        throw error_message_t(error_code_t::FILE_READ_FAILED, "Error.  Failed to read file when decoding decryptor_t object.\n");
    this->read_from_json_buffer(std::string_view(buffer));
    
}

void decryptor_t::read_from_json_buffer(std::string_view buffer)
{
    
    Json::CharReaderBuilder builder;
    Json::CharReader* reader = builder.newCharReader();
    
    Json::Value json_root;
    std::string error_message;
    bool success = reader->parse(buffer.begin(), buffer.end(), &json_root, &error_message);
    delete reader;
    if (!success)
        Json::throwRuntimeError(error_message);
    
    // Now that the JSON syntax is parsed, extract the stat_list specific
    // data.
    this->read_from_json_structure(json_root);
    
}

void decryptor_t::read_from_json_structure(const Json::Value& json_root)
{
    
    // It is OK for this field to be NULL.
    // A null or missing value indicates "don't use a decryptor".
    if (json_root.isNull())
    {
        this->type_ = type_t::NO_DECRYPTOR;
        return;
    }
    
    // Parse root
    if (!json_root.isString())
        throw error_message_t(error_code_t::JSON_SCHEMA_VIOLATION, "Error.  Root of decrypror is not of type \"string\".\n");
    std::string_view value = json_root.asString();
    
    // Decode Enum
    if (value == "no_decryptor")
        this->type_ = type_t::NO_DECRYPTOR;
    else if (value == "augmentation")
        this->type_ = type_t::AUGMENTATION;
    else if (value == "optimized_augmentation")
        this->type_ = type_t::OPTIMIZED_AUGMENTATION;
    else if (value == "symmetry")
        this->type_ = type_t::SYMMETRY;
    else if (value == "process")
        this->type_ = type_t::PROCESS;
    else if (value == "accelerant")
        this->type_ = type_t::ACCELERANT;
    else if (value == "parity")
        this->type_ = type_t::PARITY;
    else if (value == "attainment")
        this->type_ = type_t::ATTAINMENT;
    else if (value == "optimized_attainment")
        this->type_ = type_t::OPTIMIZED_ATTAINMENT;
    else
    {
        std::string message("Error.  Invalid value \"");
        message += value;
        message += "\" for decryptor in JSON input.\n";
        throw error_message_t(error_code_t::JSON_SCHEMA_VIOLATION, message);
    }
    
}

void decryptor_t::write_to_json_file(std::ostream& file) const
{
    std::string buffer;
    this->write_to_json_buffer(buffer);
    file << buffer;
    if (!file.good())
        throw error_message_t(error_code_t::FILE_WRITE_FAILED, "Error.  Failed to write file when encoding decryptor_t object.\n");
}

void decryptor_t::write_to_json_buffer(std::string& buffer) const
{
    switch (this->type_)
    {
        case type_t::NO_DECRYPTOR:
            buffer += "\"no_decryptor\"";
            return;
        case type_t::AUGMENTATION:
            buffer += "\"augmentation\"";
            return;
        case type_t::OPTIMIZED_AUGMENTATION:
            buffer += "\"optimized_augmentation\"";
            return;
        case type_t::SYMMETRY:
            buffer += "\"symmetry\"";
            return;
        case type_t::PROCESS:
            buffer += "\"process\"";
            return;
        case type_t::ACCELERANT:
            buffer += "\"accelerant\"";
            return;
        case type_t::PARITY:
            buffer += "\"parity\"";
            return;
        case type_t::ATTAINMENT:
            buffer += "\"attainment\"";
            return;
        case type_t::OPTIMIZED_ATTAINMENT:
            buffer += "\"optimized_attainment\"";
            return;
        default:
            throw error_message_t(error_code_t::UNKNOWN_DECRYPTOR_TYPE, "Error.  Tried to encode invalid decryptor.\n");
    }
}

std::istream& operator>>(std::istream& stream, decryptor_t& destination)
{
    try
    {
        destination.read_from_json_file(stream);
    } catch (const error_message_t& error) {
        stream.setstate(std::ios::failbit);
        throw error;
    } catch (const Json::Exception& error) {
        stream.setstate(std::ios::failbit);
        throw error;
    }
    return stream;
}

