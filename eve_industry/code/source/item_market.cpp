/// @file item_market.cpp
/// @brief Implementation of @ref item_market_t class
/// 
/// * Contact conor.gardner@arm.com if you have questions about this code.
/// * Date Created = Tuesday November 7 2017
/// * Documentation is generated by doxygen, see html/index.html

#include <fstream>
#include <string>
#include <string_view>
#include <vector>

#include "item_market.h"
#include "error.h"
#include "json.h"

float item_market_t::min_buy_order() const
{
    
    unsigned num_orders = this->buy_orders_.size();
    if (num_orders == 0)
    {
        std::string message("No buy orders found for item with ID ");
        message += std::to_string(this->item_id_);
        message += ".\n";
        throw error_message_t(error_code_t::NO_ORDERS, message);
    }
    
    float min_bid = this->buy_orders_.front();
    for (unsigned ix = 1; ix < num_orders; ix++)
    {
        float cur_bid = this->buy_orders_[ix];
        if (min_bid > cur_bid)
            min_bid = cur_bid;
    }
    
    return min_bid;
    
}

float item_market_t::max_buy_order() const
{
    
    unsigned num_orders = this->buy_orders_.size();
    if (num_orders == 0)
    {
        std::string message("No buy orders found for item with ID ");
        message += std::to_string(this->item_id_);
        message += ".\n";
        throw error_message_t(error_code_t::NO_ORDERS, message);
    }
    
    float max_bid = this->buy_orders_.front();
    for (unsigned ix = 1; ix < num_orders; ix++)
    {
        float cur_bid = this->buy_orders_[ix];
        if (max_bid < cur_bid)
            max_bid = cur_bid;
    }
    
    return max_bid;
    
}

float item_market_t::min_sell_order() const
{
    
    unsigned num_orders = this->sell_orders_.size();
    if (num_orders == 0)
    {
        std::string message("No sell orders found for item with ID ");
        message += std::to_string(this->item_id_);
        message += ".\n";
        throw error_message_t(error_code_t::NO_ORDERS, message);
    }
    
    float min_bid = this->sell_orders_.front();
    for (unsigned ix = 1; ix < num_orders; ix++)
    {
        float cur_bid = this->sell_orders_[ix];
        if (min_bid > cur_bid)
            min_bid = cur_bid;
    }
    
    return min_bid;
    
}

float item_market_t::max_sell_order() const
{
    
    unsigned num_orders = this->sell_orders_.size();
    if (num_orders == 0)
    {
        std::string message("No sell orders found for item with ID ");
        message += std::to_string(this->item_id_);
        message += ".\n";
        throw error_message_t(error_code_t::NO_ORDERS, message);
    }
    
    float max_bid = this->sell_orders_.front();
    for (unsigned ix = 1; ix < num_orders; ix++)
    {
        float cur_bid = this->sell_orders_[ix];
        if (max_bid < cur_bid)
            max_bid = cur_bid;
    }
    
    return max_bid;
    
}

void item_market_t::cull_unavailable_orders()
{
    
    // Cull buy orders
    if (!this->buy_orders_.empty())
    {
        float max = this->max_buy_order();
        this->buy_orders_.clear();
        this->buy_orders_.emplace_back(max);
    }
    
    // Cull sell orders
    if (!this->sell_orders_.empty())
    {
        float min = this->min_sell_order();
        this->sell_orders_.clear();
        this->sell_orders_.emplace_back(min);
    }
    
}


void item_market_t::read_from_json_file(std::istream& file)
{
    
    // Get the number of characters in the input file.
    if (!file.good())
        throw error_message_t(error_code_t::FILE_SIZE_FAILED, "Error.  Failed to determine file size when decoding item_market_t object.\n");
    file.seekg(0, std::ios_base::end);
    unsigned file_size = file.tellg();
    file.seekg(0, std::ios_base::beg);
    
    // Read the entire file into RAM at once
    std::string buffer(file_size, '\0');
    file.read(buffer.data(), file_size);
    if (!file.good())
        throw error_message_t(error_code_t::FILE_READ_FAILED, "Error.  Failed to read file when decoding item_market_t object.\n");
    this->read_from_json_buffer(std::string_view(buffer));
    
}

void item_market_t::read_from_json_buffer(std::string_view buffer)
{
    
    Json::CharReaderBuilder builder;
    Json::CharReader* reader = builder.newCharReader();
    
    Json::Value json_root;
    std::string error_message;
    bool success = reader->parse(buffer.begin(), buffer.end(), &json_root, &error_message);
    delete reader;
    if (!success)
        Json::throwRuntimeError(error_message);
    
    // Now that the JSON syntax is parsed, extract the stat_list specific
    // data.
    this->read_from_json_json(json_root);
    
}

void item_market_t::read_from_json_json(const Json::Value& json_root)
{
    
    // Parse root
    if (!json_root.isObject())
        throw error_message_t(error_code_t::JSON_SCHEMA_VIOLATION, "Error.  Root of item_market is not of type \"object\".\n");
    
    // Decode item_id
    const Json::Value& json_item_id = json_root["item_id"];
    if (!json_item_id.isUInt64())
        throw error_message_t(error_code_t::JSON_SCHEMA_VIOLATION, "Error.  <item_market>/item_id was not found or not of type \"unsigned integer\".\n");
    this->item_id_ = json_item_id.asUInt64();
    
    // Decode buy_orders
    const Json::Value& json_buy_orders = json_root["buy_orders"];
    if (!json_buy_orders.isArray())
        throw error_message_t(error_code_t::JSON_SCHEMA_VIOLATION, "Error.  <item_market>/buy_orders was not found or not of type \"array\".\n");
    unsigned num_buy_orders = json_buy_orders.size();
    this->buy_orders_.resize(num_buy_orders);
    for (unsigned ix = 0; ix < num_buy_orders; ix++)
    {
        
        const Json::Value& json_cur_buy_order = json_buy_orders[ix];
        if (!json_cur_buy_order.isNumeric())
        {
            std::string message("Error.  <item_market>buy_orders[");
            message += std::to_string(ix);
            message += "] was not of type \"float\".\n";
            throw error_message_t(error_code_t::JSON_SCHEMA_VIOLATION, message);
        }
        
        this->buy_orders_[ix] = json_cur_buy_order.asFloat();
        
    }
    
    // Decode sell_orders
    const Json::Value& json_sell_orders = json_root["sell_orders"];
    if (!json_sell_orders.isArray())
        throw error_message_t(error_code_t::JSON_SCHEMA_VIOLATION, "Error.  <item_market>/sell_orders was not found or not of type \"array\".\n");
    unsigned num_sell_orders = json_sell_orders.size();
    this->sell_orders_.resize(num_sell_orders);
    for (unsigned ix = 0; ix < num_sell_orders; ix++)
    {
        
        const Json::Value& json_cur_sell_order = json_sell_orders[ix];
        if (!json_cur_sell_order.isNumeric())
        {
            std::string message("Error.  <item_market>sell_orders[");
            message += std::to_string(ix);
            message += "] was not of type \"float\".\n";
            throw error_message_t(error_code_t::JSON_SCHEMA_VIOLATION, message);
        }
        
        this->sell_orders_[ix] = json_cur_sell_order.asFloat();
        
    }
    
}

void item_market_t::write_to_json_file(std::ostream& file, unsigned indent_start, unsigned spaces_per_tab) const
{
    file << this->write_to_json_buffer(indent_start, spaces_per_tab);
    if (!file.good())
        throw error_message_t(error_code_t::FILE_WRITE_FAILED, "Error.  Failed to write file when encoding item_market_t object.");
}

void item_market_t::write_to_json_buffer(std::string& buffer, unsigned indent_start, unsigned spaces_per_tab) const
{
    
    std::string indent_2(indent_start + 2 * spaces_per_tab, ' ');
    std::string_view indent_1(indent_2.data(), spaces_per_tab + indent_start);
    std::string_view indent_0(indent_2.data(), indent_start);
    
    // It is recommended not to start a new line before the opening brace, to
    // enable chaining.
    buffer += "{\n";
    
    // Encode item_id
    buffer += indent_1;
    buffer += "\"item_id\": ";
    buffer += std::to_string(this->item_id_);
    buffer += ",\n";
    
    // Encode buy_orders
    buffer += indent_1;
    unsigned num_buy_orders = this->buy_orders_.size();
    if (num_buy_orders == 0)
    {
        
        buffer += "\"buy_orders\": [],\n";
        
    } else {
        
        buffer += "\"buy_orders\": [\n";
        for (unsigned ix = 0, last_ix = num_buy_orders - 1; ix <= last_ix; ix++)
        {
            
            buffer += indent_2;
            buffer += std::to_string(this->buy_orders_[ix]);
            
            if (ix == last_ix)
                buffer += '\n';
            else
                buffer += ",\n";
            
        }
        
        buffer += indent_1;
        buffer += "],\n";
        
    }
    
    // Encode sell_orders
    buffer += indent_1;
    unsigned num_sell_orders = this->sell_orders_.size();
    if (num_sell_orders == 0)
    {
        
        buffer += "\"sell_orders\": []\n";
        
    } else {
        
        buffer += "\"sell_orders\": [\n";
        for (unsigned ix = 0, last_ix = num_sell_orders - 1; ix <= last_ix; ix++)
        {
            
            buffer += indent_2;
            buffer += std::to_string(this->sell_orders_[ix]);
            
            if (ix == last_ix)
                buffer += '\n';
            else
                buffer += ",\n";
            
        }
        
        buffer += indent_1;
        buffer += "]\n";
        
    }
    
    // It is recommended to not put a newline on the last brace to allow
    // comma chaining when this object is an element of an array.
    buffer += indent_0;
    buffer += '}';
    
}

std::istream& operator>>(std::istream& stream, item_market_t& destination)
{
    try
    {
        destination.read_from_json_file(stream);
    } catch (error_message_t error) {
        stream.setstate(std::ios::failbit);
        throw error;
    } catch (Json::Exception error) {
        stream.setstate(std::ios::failbit);
        throw error;
    }
    return stream;
}

