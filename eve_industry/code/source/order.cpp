/// @file order.cpp
/// @brief Implementation of @ref order_t class
/// 
/// * Contact conor.gardner@arm.com if you have questions about this code.
/// * Date Created = Tuesday October 31 2017
/// * Documentation is generated by doxygen, see documentation/html_out/index.html

#include <fstream>
#include <string>
#include <string_view>
#include <vector>

#include "order.h"
#include "error.h"
#include "json.h"

/// @brief String representations of enumeration symbols.
const std::vector<std::string_view> order_t::error_names_ =
{
    "FILE_SIZE_FAILED",
    "FILE_READ_FAILED",
    "FILE_WRITE_FAILED",
    "JSON_SCHEMA_VIOLATION",
    "UNKNOWN_ORDER_TYPE"
};

/// @brief Default error messages suitable for printing.  Note that
/// some of these are inherently vague without additional information.
const std::vector<std::string_view> order_t::default_error_messages_ =
{
    "Error.  Failed to determine size of input file.\n",
    "Error.  Failed to read content from file.\n",
    "Error.  Failed to write content to file.\n",
    "Error.  Json input does not contain the correct fields.\n",
    "Error.  Encountered an unknown value for enum order_type_t.\n"
};

void order_t::decode(std::istream& file)
{
    
    // Get the number of characters in the input file.
    if (!file.good())
        throw error_message_t(error_code_t::FILE_SIZE_FAILED);
    file.seekg(0, std::ios_base::end);
    unsigned file_size = file.tellg();
    file.seekg(0, std::ios_base::beg);
    
    // Read the entire file into RAM at once
    std::string buffer(file_size, '\0');
    file.read(buffer.data(), file_size);
    if (!file.good())
        throw error_message_t(error_code_t::FILE_READ_FAILED);
    this->decode(std::string_view(buffer));
    
}

void order_t::decode(std::string_view buffer)
{
    
    Json::CharReaderBuilder builder;
    Json::CharReader* reader = builder.newCharReader();
    
    Json::Value json_root;
    std::string error_message;
    bool success = reader->parse(buffer.begin(), buffer.end(), &json_root, &error_message);
    delete reader;
    if (!success)
        Json::throwRuntimeError(error_message);
    
    // Now that the JSON syntax is parsed, extract the stat_list specific
    // data.
    this->decode(json_root);
    
}

void order_t::decode(const Json::Value& json_root)
{
    
    // Parse root
    if (!json_root.isObject())
        throw error_message_t(error_code_t::JSON_SCHEMA_VIOLATION, "Error.  Root of order is not of type \"object\".\n");
    
    // Parse root/item_id
    const Json::Value& json_item_id = json_root["item_id"];
    if (!json_item_id.isUInt())
        throw error_message_t
        (
            error_code_t::JSON_SCHEMA_VIOLATION,
            "Error.  <order>/item_id was not found or not of type \"unsigned int\".\n"
        );
    this->item_id_ = json_item_id.asUInt();
    
    // Parse root/price
    const Json::Value& json_price = json_root["price"];
    if (!json_price.isNumeric())
        throw error_message_t
        (
            error_code_t::JSON_SCHEMA_VIOLATION,
            "Error.  <order>/price was not found or not of type \"float\".\n"
        );
    this->price_ = json_price.asFloat();
    
    // Parse root/station_id
    const Json::Value& json_station_id = json_root["station_id"];
    if (!json_station_id.isUInt())
        throw error_message_t
        (
            error_code_t::JSON_SCHEMA_VIOLATION,
            "Error.  <order>/station_id was not found or not of type \"unsigned int\".\n"
        );
    this->station_id_ = json_station_id.asUInt();
    
    // Parse root/type
    const Json::Value& json_type = json_root["type"];
    if (!json_type.isString())
        throw error_message_t
        (
            error_code_t::JSON_SCHEMA_VIOLATION,
            "Error.  <order>/type was not found or not of type \"string\".\n"
        );
    const std::string& str_type = json_type.asString();
    if (str_type == "buy")
        this->order_type_ = order_type_t::BUY;
    else if (str_type == "sell")
        this->order_type_ = order_type_t::SELL;
    else
    {
        std::string message("Error.  Value for <order>/type \"");
        message += str_type;
        message += "\" was not in the set {\"buy\", \"sell\"}";
        throw error_message_t(error_code_t::JSON_SCHEMA_VIOLATION, message);
    }
    
}

void order_t::encode(std::ostream& file, unsigned indent_start, unsigned spaces_per_tab) const
{
    file << this->encode(indent_start, spaces_per_tab);
    if (!file.good())
        throw error_message_t(error_code_t::FILE_WRITE_FAILED);
}

void order_t::encode(std::string& buffer, unsigned indent_start, unsigned spaces_per_tab) const
{
    
    std::string indent_1(indent_start + 1 * spaces_per_tab, ' ');
    std::string_view indent_0(indent_1.data(), indent_start);
    
    // It is recommended not to start a new line before the opening brace, to
    // enable chaining.
    buffer += "{\n";
    
    // Encode item_id
    buffer += indent_1;
    buffer += "\"item_id\": ";
    buffer += std::to_string(this->item_id_);
    buffer += ",\n";
    
    // Encode price
    buffer += indent_1;
    buffer += "\"price\": ";
    buffer += std::to_string(this->price_);
    buffer += ",\n";
    
    // Encode station_id
    buffer += indent_1;
    buffer += "\"station_id\": ";
    buffer += std::to_string(this->station_id_);
    buffer += ",\n";
    
    // Encode type
    buffer += indent_1;
    buffer += "\"type\": \"";
    if (this->order_type_ == order_type_t::BUY)
        buffer += "buy\"\n";
    else if (this->order_type_ == order_type_t::SELL)
        buffer += "sell\"\n";
    else
        throw error_message_t(error_code_t::UNKNOWN_ORDER_TYPE);
    
    // It is recommended to not put a newline on the last brace to allow
    // comma chaining when this object is an element of an array.
    buffer += indent_0;
    buffer += '}';
    
}

std::istream& operator>>(std::istream& stream, order_t& destination)
{
    try
    {
        destination.decode(stream);
    } catch (order_t::error_message_t error) {
        stream.setstate(std::ios::failbit);
        throw error;
    } catch (Json::Exception error) {
        stream.setstate(std::ios::failbit);
        throw error;
    }
    return stream;
}

