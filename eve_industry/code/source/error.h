/// @file error.h
/// 
/// * Contact conor.gardner@arm.com if you have questions about this code.
/// * Date Created = Tuesday September 12 2017
/// * Documentation is generated by doxygen, see html/index.html

#ifndef HEADER_GUARD_ERROR
#define HEADER_GUARD_ERROR

#include <string>
#include <string_view>
#include <vector>

/// @brief This is an object that gets thrown.  It contains an error code
/// to allow the program to reliably check the type of error that occurred
/// as well as a human readable message suitable for printing.
template
<
    typename error_code_t,
    const std::vector<std::string_view>& error_names,
    const std::vector<std::string_view>& default_error_messages
>
class error_message_template_t
{
    
    public:
        
        /// @brief Default constructor
        inline error_message_template_t() = default;
        
        /// @brief Copy constructor
        inline error_message_template_t(const error_message_template_t& source) = default;
        
        /// @brief Move constructor
        inline error_message_template_t(error_message_template_t&& source) = default;
        
        /// @brief Initialization constructor
        inline error_message_template_t(error_code_t error_code)
          : error_code_(error_code),
            message_(default_error_messages[unsigned(error_code)])
        {
            // All work done in initializer list
        }
        
        /// @brief Initialization constructor
        inline error_message_template_t(error_code_t error_code, std::string_view error_message)
          : error_code_(error_code),
            message_(error_message)
        {
            // All work done in initializer list
        }
        
        /// @brief Destructor
        inline ~error_message_template_t() = default;
        
        /// @brief Copy assignment operator
        inline error_message_template_t& operator=(const error_message_template_t& source) = default;
        
        /// @brief Move assignment operator
        inline error_message_template_t& operator=(error_message_template_t&& source) = default;
        
        /// @brief Overwrite an error code and assign default message string.
        inline error_message_template_t& operator=(error_code_t error_code)
        {
            this->error_code_ = error_code;
            this->message_ = default_error_messages[unsigned(error_code)];
            return *this;
        }
        
        /// @brief Read a specific character in the error message
        inline char operator[](unsigned ix) const
        {
            return this->message_[ix];
        }
        
        /// @brief Write a specific character in the error message
        inline char& operator[](unsigned ix)
        {
            return this->message_[ix];
        }
        
        /// @brief Since the @ref message_ "message string" shall never be
        /// used for comparison, you can compare errors based only on an error
        /// code.
        ///
        /// @return true if error codes match and false otherwise.
        inline bool operator==(error_code_t error_code) const
        {
            return this->error_code_ == error_code;
        }
        
        /// @brief Since the @ref message_ "message string" shall never be
        /// used for comparison, you can compare errors based only on an error
        /// code.
        ///
        /// @return true if error codes match and false otherwise.
        inline bool operator==(const error_message_template_t& other) const
        {
            return this->error_code_ == other.error_code_;
        }
        
        /// @brief 1:1 Inverse of equality operator
        inline bool operator!=(error_code_t error_code) const
        {
            return !(*this == error_code);
        }
        
        /// @brief 1:1 Inverse of equality operator
        inline bool operator!=(const error_message_template_t& other) const
        {
            return !(*this == other);
        }
        
        /// @brief Return the number of characters in the error message string
        /// not including the null-terminator.
        inline unsigned length() const
        {
            return this->message_.length();
        }
        
        /// @brief Read access to first character in the error message
        inline const char* begin() const
        {
            return this->message_.begin();
        }
        
        /// @brief Write access to first character in the error message
        inline char* begin()
        {
            return this->message_.begin();
        }
        
        /// @brief Const Iterator past the last character in the error message.
        inline const char* end() const
        {
            return this->message_.end();
        }
        
        /// @brief Iterator past the last character in the error_message.
        inline char* end()
        {
            return this->message_.end();
        }
        
        /// @brief Read access to @ref error_code_ member.
        inline error_code_t error_code() const
        {
            return this->error_code_;
        }
        
        /// @brief Write access to @ref error_code_ member.
        inline void error_code(error_code_t new_error_code)
        {
            this->error_code_ = new_error_code;
            this->message_ = default_error_messages[unsigned(error_code)];
        }
        
        /// @brief Read access to @ref message_ member.
        inline const std::string& message() const
        {
            return this->message_;
        }
        
        /// @brief Write access to @ref message_ member.
        inline void message(const std::string_view new_message)
        {
            this->message_ = new_message;
        }
        
        /// @brief Get the literal name of an enum symbol.
        inline static std::string_view enum_to_string(error_code_t error_code)
        {
            return error_names[unsigned(error_code)];
        }
        
        /// @brief Get the default message for an error code.
        inline static std::string_view enum_to_message(error_code_t error_code)
        {
            return default_error_messages[unsigned(error_code)];
        }
        
    protected:
        
        /// @brief Integral tag for this error.
        error_code_t error_code_;
        
        /// @brief Arbitrary human readable message suitable for printing.
        /// There shall never be any guarentees on how this member is formatted.
        /// Use @ref error_code_ to check what type of error occurred.
        std::string message_;
        
};

#endif // header guard

