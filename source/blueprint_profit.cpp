/// @file blueprint_profit.cpp
/// @brief Implementation of @ref blueprint_profit_t class
/// 
/// * Contact conor.gardner@arm.com if you have questions about this code.
/// * Date Created = Thursday November 16 2017
/// * Documentation is generated by doxygen, see html/index.html

#include <iostream>

#include <fstream>
#include <string>
#include <string_view>
#include <unordered_map>

#include "blueprint.h"
#include "blueprint_profit.h"
#include "blueprints.h"
#include "error.h"
#include "json.h"
#include "manufacturability.h"
#include "station_market.h"

void blueprint_profit_t::initialize_from_market
(
    const blueprint_t& blueprint_of_interest,
    const blueprints_t& all_blueprints,
    const station_market_t& station_market,
    const decryptor_t& decryptor
){
    
    // calculate profits for each decryptor
    
    this->blueprint_id_ = blueprint_of_interest.blueprint_id();
    
    // This will get overwritten if an error occurs
    this->manufacturability_.status(manufacturability_t::status_t::OK);
    
    this->decryptor_ = decryptor;
    
    // If this is a T1 blueprint, then the calculation is easy and requires no
    // decryptors
    const blueprint_t::manufacture_t& manufacture = blueprint_of_interest.manufacture();
    const blueprint_t::invent_t& invent = blueprint_of_interest.invent();
    if (invent.valid())
    {
        
        // This is a T2 blueprint that requires invention
        
        std::unordered_map<uint64_t, blueprint_t>::const_iterator blueprint_not_found = all_blueprints.storage().end();
        
        // Find the T1 blueprint used to invent this T2 blueprint
        uint64_t t1_blueprint_id = invent.invented_from_blueprint_id();
        const std::unordered_map<uint64_t, blueprint_t>::const_iterator t1_iterator = all_blueprints.storage().find(t1_blueprint_id);
        if (t1_iterator == blueprint_not_found)
        {
            this->manufacturability_.status(manufacturability_t::status_t::INVENT_CANNOT_FIND_REQUISITE_T1);
            std::string message("Cannot find input T1 blueprint with ID ");
            message += std::to_string(t1_blueprint_id);
            message += " for invention.";
            return;
        }
        const blueprint_t& t1_blueprint = t1_iterator->second;
        
        // Make sure that the T1 blueprint is copyable
        const blueprint_t::copy_t copy = t1_blueprint.copy();
        if (!copy.valid())
        {
            this->manufacturability_.status(manufacturability_t::status_t::INVENT_CANNOT_COPY_REQUISITE_T1);
            std::string message("Cannot copy input T1 blueprint with ID ");
            message += std::to_string(t1_blueprint_id);
            message += " for invention.";
            return;
        }
        
        // Calculate the effective number of T1 blueprints that must be copied
        // and invented per T2 manufacturing run
        float effective_num_t1_copies
          = 1.0f / (
                decryptor.modify_probability(invent.probability())
              * float(decryptor.modify_max_runs(invent.runs()))
          );
        
        // Calculate manufacturing time
        float te_modifier = float(100 - decryptor.modify_time_efficiency(invent.time_efficiency())) / 100.0f;
        this->time_ = te_modifier * effective_num_t1_copies * float(copy.time() + invent.time());
        
        // Mark blueprint as unmanufacturable if there are no market orders for
        // an input item.
        try
        {
            
            // Look up decryptor price
            float decryptor_cost = 0.0f;
            if (decryptor != decryptor_t::type_t::NO_DECRYPTOR)
            {
                std::unordered_map<uint64_t, item_market_t>::const_iterator decryptor_market_data = station_market.items().find(decryptor.item_id());
                if (decryptor_market_data == station_market.items().end())
                {
                    // No market orders for the decryptor.  Abort
                    this->manufacturability_.status(manufacturability_t::status_t::MISSING_MARKET_DATA);
                    std::string message("Could not find any market orders for decryptor with ID ");
                    message += std::to_string(decryptor.item_id());
                    message += ".\n";
                    this->manufacturability_.message(message);
                    return;
                }
                decryptor_cost = decryptor_market_data->second.min_sell_order();
            }
            
            // Calculate input material cost
            unsigned me = decryptor.modify_material_efficiency(invent.material_efficiency());
            this->total_cost_
              = effective_num_t1_copies * (
                    copy.input_materials().total_sell_value(station_market, 0)
                  + invent.input_materials().total_sell_value(station_market, 0)
                  + decryptor_cost
                )
                + manufacture.input_materials().total_sell_value(station_market, me);
            
            // Calculate output material value
            this->output_value_ = manufacture.output_materials().total_sell_value(station_market, 0);
            
            // Market calculation successful
            this->manufacturability_.status(manufacturability_t::status_t::OK);
            this->manufacturability_.message("");
            
        } catch (const error_message_t& error) {
            if (error.error_code() == error_code_t::NO_ORDERS)
            {
                this->manufacturability_.status(manufacturability_t::status_t::MISSING_MARKET_DATA);
                this->manufacturability_.message(error.message());
                return;
            } else {
                throw error;
            }
        }
        
    } else {
        
        // This is a T1 blueprint
        
        this->time_ = manufacture.time();
        
        // Calculate total cost, or mark this item as unmanufacturable if there
        // is insufficient market data.
        try
        {
            this->total_cost_ = manufacture.input_materials().total_sell_value
            (
                station_market,
                manufacture.material_efficiency()
            );
        } catch (const error_message_t& error) {
            if (error == error_code_t::NO_ORDERS)
            {
                this->manufacturability_.status(manufacturability_t::status_t::MISSING_MARKET_DATA);
                this->manufacturability_.message(error.message());
            } else {
                throw error;
            }
        }
        
        // Calculate output value
        try
        {
            this->output_value_ = manufacture.output_materials().total_sell_value
            (
                station_market,
                0 // Material efficiency does not affect output amount
            );
        } catch (const error_message_t& error) {
            if (error == error_code_t::NO_ORDERS)
            {
                this->manufacturability_.status(manufacturability_t::status_t::MISSING_MARKET_DATA);
                this->manufacturability_.message(error.message());
            } else {
                throw error;
            }
        }
        
    }
    
}

void blueprint_profit_t::read_from_json_file(std::istream& file)
{
    
    // Get the number of characters in the input file.
    if (!file.good())
        throw error_message_t(error_code_t::FILE_SIZE_FAILED, "Error.  Failed to determine file size when encoding blueprint_profit_t object.\n");
    file.seekg(0, std::ios_base::end);
    unsigned file_size = file.tellg();
    file.seekg(0, std::ios_base::beg);
    
    // Read the entire file into RAM at once
    std::string buffer(file_size, '\0');
    file.read(buffer.data(), file_size);
    if (!file.good())
        throw error_message_t(error_code_t::FILE_READ_FAILED, "Error.  Failed to read file when decoding blueprint_profit_t object.\n");
    this->read_from_json_buffer(std::string_view(buffer));
    
}

void blueprint_profit_t::read_from_json_buffer(std::string_view buffer)
{
    
    Json::CharReaderBuilder builder;
    Json::CharReader* reader = builder.newCharReader();
    
    Json::Value json_root;
    std::string error_message;
    bool success = reader->parse(buffer.begin(), buffer.end(), &json_root, &error_message);
    delete reader;
    if (!success)
        Json::throwRuntimeError(error_message);
    
    // Now that the JSON syntax is parsed, extract the stat_list specific
    // data.
    this->read_from_json_structure(json_root);
    
}

void blueprint_profit_t::read_from_json_structure(const Json::Value& json_root)
{
    
    // Parse root
    if (!json_root.isObject())
        throw error_message_t(error_code_t::JSON_SCHEMA_VIOLATION, "Error.  Root of blueprint_profit is not of type \"object\".\n");
    
    // Parse manufacturability
    this->manufacturability_.read_from_json_structure(json_root["manufacturability"]);
    
    // Parse decryptor
    this->decryptor_.read_from_json_structure(json_root["decryptor"]);
    
    // Parse blueprint_id
    const Json::Value& json_blueprint_id = json_root["blueprint_id"];
    if (!json_blueprint_id.isUInt64())
        throw error_message_t(error_code_t::JSON_SCHEMA_VIOLATION, "Error <blueprint_profit>/blueprint_id was not found or not of type \"unsigned integer\".\n");
    this->blueprint_id_ = json_blueprint_id.asUInt64();
    
    // If this blueprint cannot be manufactured, then all other fields are invalid
    if (this->manufacturability_.is_ok())
    {
        
        // Parse time
        const Json::Value& json_time = json_root["time"];
        if (!json_time.isUInt())
            throw error_message_t(error_code_t::JSON_SCHEMA_VIOLATION, "Error <blueprint_profit>/time was not found or not of type \"unsigned integer\".\n");
        this->time_ = json_time.asUInt();
        
        // Parse total_cost
        const Json::Value& json_total_cost = json_root["total_cost"];
        if (!json_total_cost.isNumeric())
            throw error_message_t(error_code_t::JSON_SCHEMA_VIOLATION, "Error <blueprint_profit>/total_cost was not found or not of type \"float\".\n");
        this->total_cost_ = json_total_cost.asFloat();
        
        // Parse output_value
        const Json::Value& json_output_value = json_root["output_value"];
        if (!json_output_value.isNumeric())
            throw error_message_t(error_code_t::JSON_SCHEMA_VIOLATION, "Error <blueprint_profit>/output_value was not found or not of type \"float\".\n");
        this->output_value_ = json_output_value.asFloat();
        
    }
    
    // Ignore derivable stats like profit_amount
    
}

void blueprint_profit_t::write_to_json_file
(
    std::ostream& file,
    const std::unordered_map<uint64_t, std::string_view>& blueprint_names,
    unsigned indent_start,
    unsigned spaces_per_tab
) const {
    std::string buffer;
    this->write_to_json_buffer(buffer, blueprint_names, indent_start, spaces_per_tab);
    file << buffer;
    if (!file.good())
        throw error_message_t(error_code_t::FILE_WRITE_FAILED, "Error.  Failed to write file when encoding blueprint_profit_t object.\n");
}

void blueprint_profit_t::write_to_json_buffer
(
    std::string& buffer,
    const std::unordered_map<uint64_t, std::string_view>& blueprint_names,
    unsigned indent_start,
    unsigned spaces_per_tab
) const {
    
    std::string indent_1(indent_start + 1 * spaces_per_tab, ' ');
    std::string_view indent_0(indent_1.data(), indent_start);
    
    // It is recommended not to start a new line before the opening brace, to
    // enable chaining.
    buffer += "{\n";
    
    buffer += indent_1;
    buffer += "\"manufacturability\": ";
    this->manufacturability_.write_to_json_buffer(buffer, indent_start + spaces_per_tab, spaces_per_tab);
    buffer += ",\n";
    
    buffer += indent_1;
    buffer += "\"decryptor\": ";
    this->decryptor_.write_to_json_buffer(buffer);
    buffer += ",\n";
    
    buffer += indent_1;
    buffer += "\"blueprint_id\": ";
    buffer += std::to_string(this->blueprint_id_);
    
    // If a name for this blueprint could be found, output it
    // else no name was found, print nothing and continue
    std::unordered_map<uint64_t, std::string_view>::const_iterator name_match = blueprint_names.find(this->blueprint_id_);
    if (name_match != blueprint_names.end())
    {
        buffer += ",\n";
        buffer += indent_1;
        buffer += "\"blueprint_name\": \"";
        buffer += name_match->second;
        buffer += '\"';
    }
    
    // All other members are only valid if this blueprint is manufacturable.
    if (this->manufacturability_.is_ok())
    {
        
        buffer += ",\n";
        
        // Encode base statistics
        
        buffer += indent_1;
        buffer += "\"time\": ";
        buffer += std::to_string(this->time_);
        buffer += ",\n";
        
        buffer += indent_1;
        buffer += "\"total_cost\": ";
        buffer += std::to_string(this->total_cost_);
        buffer += ",\n";
        
        buffer += indent_1;
        buffer += "\"output_value\": ";
        buffer += std::to_string(this->output_value_);
        buffer += ",\n";
        
        // Encode optional, derived stats.
        buffer += indent_1;
        buffer += "\"profit_amount\": ";
        buffer += std::to_string(this->profit_amount());
        buffer += ",\n";
        
        buffer += indent_1;
        buffer += "\"profit_percent\": ";
        buffer += std::to_string(this->profit_percent());
        buffer += ",\n";
        
        buffer += indent_1;
        buffer += "\"profit_per_second\": ";
        buffer += std::to_string(this->profit_per_second());
        buffer += '\n';
    
    } else {
        
        buffer += '\n';
        
    }
    
    // It is recommended to not put a newline on the last brace to allow
    // comma chaining when this object is an element of an array.
    buffer += indent_0;
    buffer += '}';
    
}

std::istream& operator>>(std::istream& stream, blueprint_profit_t& destination)
{
    try
    {
        destination.read_from_json_file(stream);
    } catch (const error_message_t& error) {
        stream.setstate(std::ios::failbit);
        throw error;
    } catch (const Json::Exception& error) {
        stream.setstate(std::ios::failbit);
        throw error;
    }
    return stream;
}

