/// @file item_id.h
/// @brief Declaration of @ref item_id_t class
/// 
/// * Contact conor.gardner@arm.com if you have questions about this code.
/// * Date Created = Saturday September 23 2017
/// * Documentation is generated by doxygen, see html/index.html

#ifndef HEADER_GUARD_ITEM_ID
#define HEADER_GUARD_ITEM_ID

#include <fstream>
#include <string>
#include <string_view>
#include <vector>

#include "error.h"
#include "json.h"

/// @brief Links the name of an item as it appears in the EvE Universe to its
/// unique integral ID used in the EvE Swagger API.
class item_id_t
{
        
    protected:
        
        /// @brief String representations of enumeration symbols.
        static const std::vector<std::string_view> error_names_;
        
        /// @brief Default error messages suitable for printing.  Note that
        /// some of these are inherently vague without additional information.
        static const std::vector<std::string_view> default_error_messages_;
        
        /// @brief Integral uniquifier used to tag this item.
        unsigned id_;
        
        /// @brief Human readable name of this item, possibly containing
        /// whitespaces, quotes, and other nasty characters.
        std::string name_;
        
    public:
        
        /// @brief Error codes are defined to facilitate programmatic detection and
        /// correction.
        enum class error_code_t
        {
            FILE_SIZE_FAILED,
            FILE_READ_FAILED,
            FILE_WRITE_FAILED,
            JSON_SCHEMA_VIOLATION,
            /// This element must be last
            NUM_ENUMS
        };
        
        typedef error_message_template_t
        <
            error_code_t,
            error_names_,
            default_error_messages_
        > error_message_t;
        
        /// @brief Default constructor
        inline item_id_t() = default;
        
        /// @brief Copy constructor
        inline item_id_t(const item_id_t& source) = default;
        
        /// @brief Move constructor
        inline item_id_t(item_id_t&& source) = default;
        
        /// @brief Initialization constructor
        inline item_id_t(unsigned id, std::string_view name)
          : id_(id),
            name_(name)
        {
            // All work done in initializer list.
        }
        
        /// See @ref decode(std::istream& file)
        ///
        /// @exception error_message_t
        /// @exception Json::Exception
        inline item_id_t(std::istream& file)
        {
            this->decode(file);
        }
        
        /// @brief See @ref decode(std::istream& file)
        ///
        /// @exception error_message_t
        /// @exception Json::Exception
        inline item_id_t(std::string_view buffer)
        {
            this->decode(buffer);
        }
        
        /// @brief See @ref decode(const Json::Value& json_root)
        ///
        /// @exception error_message_t
        inline item_id_t(const Json::Value& json_root)
        {
            this->decode(json_root);
        }
        
        /// @brief Destructor
        inline ~item_id_t() = default;
        
        /// @brief Assignment operator with deep copy.
        inline item_id_t& operator=(const item_id_t& source) = default;
        
        /// @brief Assignment operator with shallow copy.
        inline item_id_t& operator=(item_id_t&& source) = default;
        
        /// @brief See @ref decode(std::istream& file)
        ///
        /// @exception error_message_t
        /// @exception Json::Exception
        inline item_id_t& operator=(std::istream& file)
        {
            this->decode(file);
            return *this;
        }
        
        /// @brief See @ref decode(std::string_view buffer)
        ///
        /// @exception error_message_t
        /// @exception Json::Exception
        inline item_id_t& operator=(std::string_view buffer)
        {
            this->decode(buffer);
            return *this;
        }
        
        /// @brief See @ref decode(const Json::Value& json_root)
        ///
        /// @exception error_message_t
        inline item_id_t& operator=(const Json::Value& json_root)
        {
            this->decode(json_root);
            return *this;
        }
        
        // Add operator[] here if desired.
        // inline type operator[](unsigned ix) const;
        // inline type& operator[](unsigned ix);
        
        /// @brief Returns true if two item IDs match.
        ///
        /// Since each item has a unique ID, there is no need to check
        /// the other members.
        inline bool operator==(const item_id_t& source) const
        {
            return this->id_ == source.id_;
        }
        
        /// @brief Returns true if two item IDs match.
        ///
        /// Since each item has a unique ID, there is no need to check
        /// the other members.
        inline bool operator==(unsigned id) const
        {
            return this->id_ == id;
        }
        
        /// @brief 1:1 inverse of @ref operator==(const item_id_t& source) const "operator==".
        inline bool operator!=(const item_id_t& source) const
        {
            return !(*this == source);
        }
        
        /// @brief 1:1 inverse of @ref operator==(unsigned id) const "operator==".
        inline bool operator!=(unsigned id) const
        {
            return !(*this == id);
        }
        
        // Add member read and write functions here
        // inline type member() const;
        // inline void member(const type& t);
        
        /// @brief Read access to @ref id_ member.
        inline unsigned id() const
        {
            return this->id_;
        }
        
        /// @brief Write access to @ref id_ member.
        inline void id(unsigned new_id)
        {
            this->id_ = new_id;
        }
        
        /// @brief Read access to @ref name_ member.
        inline const std::string& name() const
        {
            return this->name_;
        }
        
        /// @brief Write access to @ref name_ member.
        inline void id(std::string_view new_name)
        {
            this->name_ = new_name;
        }
        
        /// @brief Open a file conforming to data/json/schema.json and use it to initialize
        /// this object, clearing previous content.
        ///
        /// @exception error_message_t
        /// @exception Json::Exception
        void decode(std::istream& file);
        
        /// @brief Decode serialized content conforming to data/json/schema.json and use it
        /// to initialize this object, clearing previous content.
        ///
        /// @exception error_message_t
        /// @exception Json::Exception
        void decode(std::string_view buffer);
        
        /// @brief Extract required data fields from a pre-parsed JSON tree
        /// and use them to initialize this object, clearing previous content.
        ///
        /// @exception error_message_t
        void decode(const Json::Value& json_root);
        
        /// @brief Serialize the content of this file into a file that
        /// conforms to the schema data/json/schema.json.
        void encode
        (
            /// [out] Stream to append serialized object content to.
            std::ostream& file,
            /// [in] The number of space ' ' characters to prepend to each line
            /// in the serialized output.
            unsigned indent_start = 0,
            /// [in] The number of additional spaces ' ' on top of indent_start
            /// to prepend to each line in the serialized output for each
            /// additional level of nesting.
            ///
            /// Indentation typically increases after each opening bracket '['
            /// or brace '{' and decreases after each closing bracket ']' or
            /// brace '}'.
            unsigned spaces_per_tab = 4
        ) const;
        
        /// @brief Serialize the content of this file into a string that
        /// conforms to the schema data/json/schema.json.
        ///
        /// @exception error_message_t
        void encode
        (
            /// [out] This string is overwritten with serialzed JSON content.
            std::string& buffer,
            /// [in] The number of space ' ' characters to prepend to each line
            /// in the serialized output.
            unsigned indent_start = 0,
            /// [in] The number of additional spaces ' ' on top of indent_start
            /// to prepend to each line in the serialized output for each
            /// additional level of nesting.
            ///
            /// Indentation typically increases after each opening bracket '['
            /// or brace '{' and decreases after each closing bracket ']' or
            /// brace '}'.
            unsigned spaces_per_tab = 4
        ) const;
        
        /// @brief Convinence method for pretty initialize-on-construction
        /// syntax.
        inline std::string encode
        (
            /// [in] The number of space ' ' characters to prepend to each line
            /// in the serialized output.
            unsigned indent_start = 0,
            /// [in] The number of additional spaces ' ' on top of indent_start
            /// to prepend to each line in the serialized output for each
            /// additional level of nesting.
            ///
            /// Indentation typically increases after each opening bracket '['
            /// or brace '{' and decreases after each closing bracket ']' or
            /// brace '}'.
            unsigned spaces_per_tab = 4
        ) const {
            std::string buffer;
            this->encode(buffer, indent_start, spaces_per_tab);
            return buffer;
        }
        
};

/// @brief Convenience alias to allow printing directly via cout or similar.
inline std::ostream& operator<<(std::ostream& stream, item_id_t::error_code_t error_code)
{
    stream << item_id_t::error_message_t::enum_to_string(error_code);
    return stream;
}

/// @brief Convenience alias to allow printing directly via cout or similar.
inline std::ostream& operator<<(std::ostream& stream, const item_id_t::error_message_t& error_message)
{
    stream << error_message.message();
    return stream;
}

/// @brief Convenience alias to allow printing directly via cout or similar.
inline std::ostream& operator<<(std::ostream& stream, const item_id_t& source)
{
    stream << source.encode();
    return stream;
}

/// @brief Convenience alias to allow printing directly via cout or similar.
inline std::string& operator<<(std::string& buffer, const item_id_t& source)
{
    buffer += source.encode();
    return buffer;
}

/// @brief Extraction operator for decoding.
std::istream& operator>>(std::istream& stream, item_id_t& destination);

/// @brief Extraction operator for decoding.
inline std::string_view operator>>(std::string_view& buffer, item_id_t& destination)
{
    destination.decode(buffer);
    return std::string_view();
}

/// @brief Extraction operator for decoding.
inline Json::Value operator>>(const Json::Value& json_root, item_id_t& destination)
{
    destination.decode(json_root);
    return Json::Value();
}

#endif // Header Guard

