/// @file galactic_profits.cpp
/// @brief Implementation of @ref galactic_profits_t class
/// 
/// * Contact conor.gardner@arm.com if you have questions about this code.
/// * Date Created = Thursday November 16 2017
/// * Documentation is generated by doxygen, see html/index.html

#include <fstream>
#include <string>
#include <string_view>

#include "error.h"
#include "galactic_market.h"
#include "galactic_profits.h"
#include "json.h"

void galactic_profits_t::caclulate_station_profits
(
    const blueprints_t& blueprints,
    const galactic_market_t& galactic_market,
    blueprint_profit_t::sort_strategy_t decryptor_optimization_strategy
){
    
    // Clear previous content
    this->station_profits_.clear();
    
    // Iterate through each station with a market hub
    for (const std::pair<uint64_t, regional_market_t>& cur_regional_market : galactic_market.regions())
    {
        for (const std::pair<uint64_t, station_market_t>& cur_station_market : cur_regional_market.second.stations())
        {
            station_profits_t new_station_profits;
            new_station_profits.calculate_blueprint_profits(blueprints, cur_station_market.second, decryptor_optimization_strategy);
            this->station_profits_.emplace_back(std::move(new_station_profits));
        }
    }
    
}

void galactic_profits_t::read_from_json_file(std::istream& file)
{
    
    // Get the number of characters in the input file.
    if (!file.good())
        throw error_message_t(error_code_t::FILE_SIZE_FAILED, "Error.  Failed to determine file size when encoding galactic_profits_t object.\n");
    file.seekg(0, std::ios_base::end);
    unsigned file_size = file.tellg();
    file.seekg(0, std::ios_base::beg);
    
    // Read the entire file into RAM at once
    std::string buffer(file_size, '\0');
    file.read(buffer.data(), file_size);
    if (!file.good())
        throw error_message_t(error_code_t::FILE_READ_FAILED, "Error.  Failed to read file when decoding galactic_profits_t object.\n");
    this->read_from_json_buffer(std::string_view(buffer));
    
}

void galactic_profits_t::read_from_json_buffer(std::string_view buffer)
{
    
    Json::CharReaderBuilder builder;
    Json::CharReader* reader = builder.newCharReader();
    
    Json::Value json_root;
    std::string error_message;
    bool success = reader->parse(buffer.begin(), buffer.end(), &json_root, &error_message);
    delete reader;
    if (!success)
        Json::throwRuntimeError(error_message);
    
    // Now that the JSON syntax is parsed, extract the stat_list specific
    // data.
    this->read_from_json_structure(json_root);
    
}

void galactic_profits_t::read_from_json_structure(const Json::Value& json_root)
{
    
    // Parse root
    if (!json_root.isArray())
        throw error_message_t(error_code_t::JSON_SCHEMA_VIOLATION, "Error.  Root of galactic_profits_t is not of type \"array\".\n");
    
    // Re-Allocate storage
    this->station_profits_.clear();
    this->station_profits_.reserve(json_root.size());
    
    // Decode each element of the array
    for (const Json::Value& cur_json_element : json_root)
    {
        station_profits_t station_profits;
        station_profits.read_from_json_structure(cur_json_element);
        this->station_profits_.emplace_back(std::move(station_profits));
    }
    
}

void galactic_profits_t::write_to_json_file
(
    std::ostream& file,
    blueprint_profit_t::sort_strategy_t output_order,
    unsigned indent_start,
    unsigned spaces_per_tab
) const {
    std::string buffer;
    this->write_to_json_buffer(buffer, output_order, indent_start, spaces_per_tab);
    file << buffer;
    if (!file.good())
        throw error_message_t(error_code_t::FILE_WRITE_FAILED, "Error.  Failed to write file when encoding galactic_profits_t object.\n");
}

void galactic_profits_t::write_to_json_buffer
(
    std::string& buffer,
    blueprint_profit_t::sort_strategy_t output_order,
    unsigned indent_start,
    unsigned spaces_per_tab
) const {
    
    std::string indent_1(indent_start + 1 * spaces_per_tab, ' ');
    std::string_view indent_0(indent_1.data(), indent_start);
    
    // Use compact notation for an empty object
    unsigned num_stations = this->station_profits_.size();
    if (num_stations == 0)
    {
        buffer += "[]";
        return;
    }
    
    // It is recommended not to start a new line before the opening brace, to
    // enable chaining.
    buffer += "[\n";
    
    // Encode each station's profit report.
    buffer += indent_1;
    for (unsigned ix = 0, last_ix = num_stations - 1; ix <= last_ix; ix++)
    {
        this->station_profits_[ix].write_to_json_buffer(buffer, output_order, indent_start + spaces_per_tab, spaces_per_tab);
        if (ix == last_ix)
            buffer += '\n';
        else
            buffer += ", ";
    }
    
    // It is recommended to not put a newline on the last brace to allow
    // comma chaining when this object is an element of an array.
    buffer += indent_0;
    buffer += ']';
    
}

std::istream& operator>>(std::istream& stream, galactic_profits_t& destination)
{
    try
    {
        destination.read_from_json_file(stream);
    } catch (const error_message_t& error) {
        stream.setstate(std::ios::failbit);
        throw error;
    } catch (const Json::Exception& error) {
        stream.setstate(std::ios::failbit);
        throw error;
    }
    return stream;
}

