/// @file page_fetcher.h
/// @brief Declaration of @ref page_fetcher_t class
/// 
/// * Contact conor.gardner@arm.com if you have questions about this code.
/// * Date Created = Thursday November 9 2017
/// * Documentation is generated by doxygen, see html/index.html

#ifndef HEADER_GUARD_PAGE_FETCHER
#define HEADER_GUARD_PAGE_FETCHER

#include <atomic>
#include <fstream>
#include <mutex>
#include <string_view>
#include <vector>

#include "debug_mode.h"
#include "error.h"
#include "json.h"

/// @brief Spawns multiple worker threads to speculativly fetch
/// multi-page data from the EvE API.
class page_fetcher_t
{
        
    public:
        
        /// @brief Default constructor
        inline page_fetcher_t()
        {
            this->next_page_ = 1;
            this->kill_switch_ = false;
            this->last_print_length_ = 0;
        }
        
        // Add member initialization constructors here
        // Try to use initializer lists when possible.
        
        // Add operators here if desired.
        
        // Add member read and write functions
        // inline type member() const;
        // inline void member(const type& t);
        
        inline const std::string& base_url() const
        {
            return this->base_url_;
        }
        
        inline void base_url(std::string_view new_base_url)
        {
            this->base_url_ = new_base_url;
        }
        
        inline const debug_mode_t& debug_mode() const
        {
            return this->debug_mode_;
        }
        
        inline void debug_mode(const debug_mode_t& new_debug_mode)
        {
            this->debug_mode_ = new_debug_mode;
        }
        
        // Add special-purpose functions here
        
        /// @brief Pull all of the pages from @ref base_url_, fetching
        /// multiple pages in parallel.
        ///
        /// @return The data fetched from each page
        std::vector<Json::Value> parallel_fetch(unsigned num_threads);
        
        /// @brief Open a file conforming to data/json/schema.json and use it to initialize
        /// this object, clearing previous content.
        ///
        /// @exception error_message_t
        /// @exception Json::Exception
        void read_from_file(std::istream& file);
        
        /// @brief Decode serialized content conforming to data/json/schema.json and use it
        /// to initialize this object, clearing previous content.
        ///
        /// @exception error_message_t
        /// @exception Json::Exception
        void read_from_buffer(std::string_view buffer);
        
        /// @brief Extract required data fields from a pre-parsed JSON tree
        /// and use them to initialize this object, clearing previous content.
        ///
        /// @exception error_message_t
        void read_from_json(const Json::Value& json_root);
        
        /// @brief Serialize the content of this file into a file that
        /// conforms to the schema data/json/schema.json.
        void write_to_file
        (
            /// [out] Stream to append serialized object content to.
            std::ostream& file,
            /// [in] The number of space ' ' characters to prepend to each line
            /// in the serialized output.
            unsigned indent_start = 0,
            /// [in] The number of additional spaces ' ' on top of indent_start
            /// to prepend to each line in the serialized output for each
            /// additional level of nesting.
            ///
            /// Indentation typically increases after each opening bracket '['
            /// or brace '{' and decreases after each closing bracket ']' or
            /// brace '}'.
            unsigned spaces_per_tab = 4
        ) const;
        
        /// @brief Serialize the content of this file into a string that
        /// conforms to the schema data/json/schema.json.
        ///
        /// @exception error_message_t
        void write_to_buffer
        (
            /// [out] This string is overwritten with serialzed JSON content.
            std::string& buffer,
            /// [in] The number of space ' ' characters to prepend to each line
            /// in the serialized output.
            unsigned indent_start = 0,
            /// [in] The number of additional spaces ' ' on top of indent_start
            /// to prepend to each line in the serialized output for each
            /// additional level of nesting.
            ///
            /// Indentation typically increases after each opening bracket '['
            /// or brace '{' and decreases after each closing bracket ']' or
            /// brace '}'.
            unsigned spaces_per_tab = 4
        ) const;
        
        /// @brief Convinence method for pretty initialize-on-construction
        /// syntax.
        inline std::string write_to_buffer
        (
            /// [in] The number of space ' ' characters to prepend to each line
            /// in the serialized output.
            unsigned indent_start = 0,
            /// [in] The number of additional spaces ' ' on top of indent_start
            /// to prepend to each line in the serialized output for each
            /// additional level of nesting.
            ///
            /// Indentation typically increases after each opening bracket '['
            /// or brace '{' and decreases after each closing bracket ']' or
            /// brace '}'.
            unsigned spaces_per_tab = 4
        ) const {
            std::string buffer;
            this->write_to_buffer(buffer, indent_start, spaces_per_tab);
            return buffer;
        }
        
    protected:
        
        // Try to make your members protected, even if they don't have to be.
        
        /// @brief URL to fetch data from, without a "&page=x" suffix.
        std::string base_url_;
        
        /// @brief Starts at 1.  Each worker thread pulls a page number
        /// from this variable and then atomically increments it.
        std::atomic<unsigned> next_page_;
        
        /// @brief If a worker thread fails or detects the last page
        /// this is set to true to indicate that other workers should
        /// terminate.
        /// 
        /// *   False means keep going.
        /// *   True means keep fetching
        volatile bool kill_switch_;
        
        /// @brief Used to serialize allocations to return value of
        /// @ref parallel_fetch(unsigned num_threads).
        std::mutex output_lock_;
        
        /// @brief Enables printing of extra diagnostic messages.
        debug_mode_t debug_mode_;
        
        /// @brief Tracks how many characters need to be erased
        /// when diagnostics are printed
        volatile unsigned last_print_length_;
        
        /// @brief Guards std::cout and similar.
        std::mutex print_lock_;
        
        /// @brief Output @ref last_print_length_ backspace characters to stdout.
        void erase_terminal();
        
        /// @brief Thread-safe function for grabbing market data.
        void worker_function(std::vector<Json::Value>* output);
        
};

/// @brief Convenience alias to allow printing directly via cout or similar.
inline std::ostream& operator<<(std::ostream& stream, const page_fetcher_t& source)
{
    source.write_to_file(stream);
    return stream;
}

/// @brief Extraction operator for decoding.
std::istream& operator>>(std::istream& stream, page_fetcher_t& destination);

#endif // Header Guard

